---
layout: post
title: "[05] Software Configuration Management"
date: 2022-10-17 14:40:00 +0200
toc: true
---

# SCM
Le soluzioni di Software Configuration Management nascono da problemi complessi purtroppo molto comuni nel mondo dello sviluppo software, come:
- pubblicare un _hotfix_ su una versione precedente a quella in cui si sta sviluppando. Può essere difficile localizzare le versioni vecchie, modificarle e rimappare le modifiche sulle versioni nuove;
- condividere lavori con altri gestendo accessi contemporanei e conflitti;
- stabilire la responsabilità di ciascuna linea di codice. 

Il Software Configuration Management è l'insieme di pratiche che hanno l'obiettivo di rendere sistematico il processo di sviluppo, tenendo tarccia dei cambiamenti in modo che il prodotto sia in ogni instante in uno stato (_configurazione_) ben definito.

## Storia
Il Configuration Management negli anni '50 nell'ambito dell'industria aerospaziale. 
Alla fine degli anni '70 inizia ad essere applicato all'ingegneria del software.

Gli oggetti di cui si controlla l'evoluzione sono detti _configuration item_ o _artifact_ (manufatti).

- anni '80: strumenti locali (SCCS, ...)
- anni '90: strumenti client-server centralizzati (CVS, subversion, ...)
- anni '00: strumenti distribuiti peer-to-peer (git, mercurial, bazaar, ...)

Git nasce da un'esigenza di Linus Torvalds con il kernel Linux.

## Centralizzato vs decentralizzato
<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/4XpnKHJAok8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

Il mondo open source preferisce un approccio decentralizzato al version control. Perché?
- è possibile lavorare offline;
- è molto più veloce, perché la rete non fa più da _bottleneck_;
- supporta diversi modi di lavorare:
    - simil centralizzato: un repository viene considerato "di riferimento";
    - due peer che collaborano direttamente;
    - gerarchico a più livelli (kernel Linux).

Non c'è sincronizzazione automatica, ma ci sono comandi espliciti per fare _merge_ tra repository remote.
In Git, per via della sua struttura modulare, è possibile utilizzare il proprio algoritmo _merge_ rispetto a quelli già inclusi. 

## Manufatti
Gli _"oggetti"_ di cui si controlla l'evoluzione sono detti _configuration item_ o manufatti; generalmente sono file.
Se si cambia nome a un file è come eliminarne uno e partire da zero con uno nuovo. 
Originariamente i tool tracciavano i file indipendentemente, senza un senso logico (una _configurazione_) comune. 

{% responsive_image path: 'assets/05_configuration-management.png' %}

### Cosa tracciare?
Qualunque sistema si usi, occorre prendere decisioni importanti che influenzano la replicabilità della produzione.
- Si traccia l'evoluzione anche di componenti fuori dal nostro controllo (librerie, compilatori)?
- Si archiviano i file che sostitusicono il prodotto (eseguibile, ecc...)?

La risposta ad entrambe queste domande è __no__, perché è scomodo, anti economico, costoso...
Questo porta però problemi, perché non c'è perfetta replicabilità.

## Meccanismo di base
Ogni cambiamento è regolato da:
- __check-out__: dichiara la volontà di lavorare partendo da una particolare revisione di un manufatto (o di una configurazione di diversi manufatti);
- __check-in__ (o __commit__): dichiara la volonta di registrarne una nuova (spesso chiamata change-set).

Queste operazioni vengono attivate rispetto a un _repository_.
Scambio di dati tra il repository (che contiene tutte le configurazioni) e il workspace (l'ambiente in cui si trova nel filesystem).

Solitamente ho un repository e $$n$$ workspace, uno per ogni ambiente dove sto lavorando.

### Repository
La repository mantiene:
- date
- etichette
- versioni
- diramazioni (branches)
- ecc...

Per risparmiare spazio, le repository salvano solo le differenze tra una versione e l'altra. 
In realtà, Git non fa così, perché usa link simbolici: fare il _checkout_ di una specifica versione è instantaneo.

Le repository possono essere centralizzate o distribuite.

Nei sistemi di versioning distribuiti c'è il concetto di __hashing__, in modo da identificare file uguali anche se in posizioni diverse.
Per confrontare storie diverse si utilizzano gli hash dei file e delle directory.

### Accesso concorrente

Quando il repository è condiviso da un gruppo di lavoro, nasce il problema di gestirne l'accesso concorrente. 
Esistono due modelli:
- __modello _'pessimistico'___ (RCS): prevedo il possibile conflitto assicurandomi che chi lavora sia l'unico con l'accesso in scrittura. Funziona solo in ambienti centralizzati, nell'open source non può funzionare.
- __modello _'ottimistico'___ (CVS): il sistema si disinteressa del problema e fornisce supporto per le attività di _merge_ di change-set paralleli potenzialmente conflittuali. 
    
Il modello ottimistico può essere regolato con i branch: l'attività di _merge_ è quindi fondamentale.
CVS/Subversion scoraggiava i branch, Git li rende facili e li incoraggia.
In Git, l'uso dei branch è talmente comune che a volte è necessario introdurre delle politiche (come GitFlow) sul loro utilizzo.

# Git 

{% responsive_image path: 'assets/05_git-schema.png' %}

- a sinistra ci sono gli stash
- a destra ci sono $$n$$ remote
