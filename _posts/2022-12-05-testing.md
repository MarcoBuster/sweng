---
layout: post
title: "[13] Testing e processi di review"
date:   2022-12-05 14:30:00 +0200
toc: true
---

# Test funzionale

Il test funzionale è un tipo di test utilizzato nell'ingegneria del software per verificare che un sistema software soddisfi i requisiti funzionali specificati. Si tratta di un approccio basato sulla "scatola nera", ovvero non si sfrutta la conoscenza del codice sorgente del software per creare i casi di test.

In alcuni contesti possono essere l'unico approccio possibile, per esempio se stiamo validando il lavoro del committente esterno.

I dati di test per i test funzionali possono essere derivati dalle specifiche del sistema, che descrivono i requisiti funzionali che il software deve soddisfare. In genere, queste specifiche includono informazioni sulle funzioni che il software deve eseguire, sui dati che il software deve gestire e su come il software deve interagire con gli utenti e con altri sistemi.

.....


### Tecniche

Per creare i dati di test, è possibile utilizzare diverse tecniche, come ad esempio:

- Metodi basati su grafi: per esempio, il diagramma di sequenza può essere utilizzato per rappresentare le interazioni tra le diverse funzioni del sistema e per generare i casi di test.
- Suddivisioni del dominio in classi di equivalenza: questa tecnica prevede la suddivisione dei valori del dominio di una determinata funzione o caratteristica del sistema software in classi di equivalenza, ovvero gruppi di valori che devono essere trattati allo stesso modo dal sistema.
- Analisi dei valori limite (test di frontiera): questa tecnica prevede la creazione di casi di test che coprano i valori limite del dominio di una determinata funzione o caratteristica del sistema, come ad esempio i valori minimi e massimi, o i valori che si trovano ai confini tra diverse classi di equivalenza.
- Collaudo per confronto: in questo caso, si utilizza un software noto per eseguire la stessa funzione o la stessa operazione del software da testare, e si confrontano i risultati ottenuti per verificare che il software da testare funzioni correttamente.

#### Test delle interfacce

Tipi di interfacce:
- ad invocazione con parametri
- a condivisione di memoria
- a metodi sincroni
- a passaggio di messaggi


Tipi di errori:
- sbaglio nell'uso dell'interfaccia
- ...

#### Classi di equivalenza

Le classi di equivalenza sono una tecnica utilizzata nei test del software per suddividere il dominio dei dati in ingresso in classi di dati, dalle quali derivare casi di test. 
L'obiettivo di questa tecnica è quello di individuare casi di test che rivelino eventuali classi di errori, ovvero gruppi di valori che dovrebbero essere trattati in maniera analoga dal programma ma che invece causano errori o comportamenti inaspettati.

Una classi di dati è un insieme i cui componenti dovrebbero essere trattati in maniera analoga dal programma.

Si cerca quindi di individuare casi di test che rivelino eventuali classi di errori (come numeri negativi o numeri troppo grandi). 
Le classi di equivalenza basate sugli errori sono tra le più stabili, perché danno sempre lo stesso risultato.

Una classe di equivalenza è quindi un insieme di stati validi o non validi per i dati di input e un insieme di stati validi per i dati di output

Per esempio, possiamo __suddividere in classi__ un codice PIN in questo modo:
1. PIN corretto;
2. numero di 4 cifre qualsiasi diverso dal PIN.

#### Test di frontiera

Il test di frontiera è una tecnica utilizzata nei test del software per selezionare casi di test che esercitino i valori limite del dominio di una determinata funzione o caratteristica del sistema. 
ùGli errori tendono ad accumularsi ai limiti del dominio, per cui è importante selezionare casi di test che esercitino questi valori limite per verificare che il sistema funzioni correttamente in queste condizioni.

Il test di frontiera è una tecnica complementare alla suddivisione del dominio in classi di equivalenza. Invece di scegliere un elemento a caso della classe, il test di frontiera prevede la selezione di un valore limite della classe, ovvero un valore che si trova ai confini tra diverse classi di equivalenza.

#### Category partition

È un particolare metodo di suddivisione di classi di equivalenza usabile a diversi livelli di granularità. 

È composto dai seguenti passi:
1. Analizzare le specifiche, indivuando le _unità funzionali_ individuali che possono essere verificate singolarmente; per ogni unità identificare le caratteristiche dei parametri e dell'ambiente
2. Scegliere dei valori per le categorie
3. Determinare le classi di equivalenza per ogni unità funzionale, basandosi sui valori delle categorie scelti
4. Creare dei casi di test per ogni classe di equivalenza, verificando che le unità funzionali funzionino correttamente per ogni classe

##### Pairwise
Una tecnica è utilizzare pairwise, piuttosto che far esplodere il numero di test in maniera combinatoria.

<!-- AI: verificare correttezza -->
> Il pairwise testing è una tecnica utilizzata nei test del software che appartiene alla categoria delle tecniche di category partition.
> 
> Il pairwise testing consiste nella creazione di casi di test che coprano tutte le possibili combinazioni di valori per due categorie di input alla volta. Ad esempio, supponiamo di avere una funzione che calcola il totale di un ordine in un negozio online, come descritto nell'esempio precedente. In questo caso, le categorie potrebbero essere il prezzo degli articoli e il numero di pezzi. Il pairwise testing prevederebbe la creazione di casi di test che coprano tutte le combinazioni possibili di valori per il prezzo degli articoli e il numero di pezzi, ad esempio:
> 
> - Un articolo a 1 euro, 1 pezzo
> - Un articolo a 1 euro, 2 pezzi
> - Un articolo a 1 euro, 3 pezzi
> - Un articolo a 10 euro, 1 pezzo
> - Un articolo a 10 euro, 2 pezzi
> - Un articolo a 10 euro, 3 pezzi
> - Un articolo a 100 euro, 1 pezzo
> - Un articolo a 100 euro, 2 pezzi
> - Un articolo a 100 euro, 3 pezzi
> 
> Il pairwise testing è una tecnica utile per creare casi di test efficienti e accurati, poiché permette di coprire tutte le possibili combinazioni di valori per due categorie di input alla volta. Tuttavia, può essere difficile da applicare in casi con un numero elevato di categorie di input, poiché il numero di casi di test generati cresce esponenzialmente con il numero di categorie.

## Test funzionale e OO?

...

### Software inspection

Sono tecniche manuali per individuare e correggere gli errori basati su una attività di gruppo: la pair programming nei punti di forza c'è questo.

La Fagan code inspection è una metodologia sviluppata da Michael Fagan alla IBM negli anni '70. La metodologia prevede che un gruppo di esperti esegua una serie di passi per verificare il codice sorgente, al fine di individuare eventuali errori, incongruenze o altri problemi.

#### Ruoli

- Moderatore: è colui che ha la responsabilità di mantenere e far rispettare le regole; è di solito preso da un altro processo / progetto in modo da non avere interessi. Coordina i meeting e sceglie i partecipanti;
- Readers e Testers: leggono il codice al gruppo, cercano difetti;
- Autore: partecipante passivo, risponde ad eventuali domande.
È simile al ruolo del cliente dell'eXtreme Programming.


#### Processo

<!-- AI: verificare correttezza -->

Il processo di ispezione del codice è una tecnica utilizzata per verificare che il codice sorgente soddisfi i requisiti e le buone pratiche di progettazione e sviluppo. La ispezione del codice prevede una serie di passi, dalla pianificazione alla verifica del codice, all'eventuale rilavorazione e alla verifica finale.

1. Planning: il primo passo del processo di ispezione del codice è la pianificazione, ovvero la definizione degli obiettivi e delle regole che il codice deve seguire per essere considerato corretto. In questa fase si definiscono anche i ruoli dei partecipanti e il tempo da dedicare alla ispezione.

2. Overview: in questa fase si effettua una prima analisi del codice, senza eseguire una verifica dettagliata. Il gruppo di esperti analizza il codice in modo superficiale, individuando le aree che potrebbero presentare maggiori rischi di errore e pianificando la successiva ispezione dettagliata.

3. Preparation: in questa fase si preparano le informazioni e gli strumenti necessari per eseguire la ispezione dettagliata del codice. Il gruppo di esperti raccoglie il codice sorgente, le specifiche tecniche e i documenti di progettazione, e definisce il metodo di ispezione da utilizzare.

4. Inspection: in questa fase si esegue la ispezione dettagliata del codice, verificando che esso soddisfi le regole definite in precedenza e segnalando eventuali problemi o anomalie. Durante l'ispezione, il gruppo di esperti esamina il codice riga per riga, confrontando il codice con le specifiche e cercando di individuare errori, incongruenze o altri problemi.

5.  Rework: una volta individuati i problemi, il gruppo di esperti può decidere di rilavorare il codice per correggere gli errori o per apportare modifiche. In questa fase il codice viene riscritto o modificato in modo da soddisfare i requisiti e le buone pratiche di progettazione e sviluppo.

6. Followup: ---

.... checklist ...

### Incentive structure

I difetti trovati non devono essere utilizzati per la valutazione del personale: il programmatore non va incentivato a nascondere i difetti.

C'è invece il premio dei difetti trovati dal test per valutare il personale.
Il programmatore è incentivato a trovare tutti i difetti durante l'ispezione.

#### Variante: Active Design Reviews

....

### Automazione dell'ispezione
...

### Funziona?

Principalmente sì.

...

È meglio unire tutte le tecniche per trovare la stragrande maggioranza degli errori.


## Debugging

Non deve essere usato per rilevare malfunzionamenti.
L'attività è definita per un programma e un insieme di dati che causano malfunzionamenti nel programma.
L'obeittivo è trovare la riproducibilità del malfunzionamento.
Va verificato che il malfunzionamento non sia dovuto a specifiche erreate.

<!-- AI: verificare correttezza -->
Il debugging è il processo di individuazione e correzione di errori nel codice sorgente di un programma.

Non va utilizzato per rilevare malfunzionamenti in modo casuale, ma deve essere pianificato e focalizzato su un determinato programma e un insieme di dati che causano malfunzionamenti.

L'obiettivo del debugging è quello di trovare la riproducibilità del malfunzionamento, cioè individuare le condizioni che causano l'errore, in modo da poterlo correggere.

È importante anche verificare che il malfunzionamento non sia dovuto a specifiche errate o a problemi di altro tipo, ad esempio a una configurazione del sistema non corretta. 
Il debugging richiede una comprensione approfondita del codice e del funzionamento del programma, e può essere un processo complesso e articolato. 
Tuttavia, può contribuire in modo significativo a migliorare la qualità e la stabilità del codice.

...

### Tecnica naive

Consiste nell'introdurre nel modulo in esame comandi di uscita che stampino il valore intermedio assunto dalle variabili.

- facile da applicare;
- richiede la modifica del codice;
- poco flessibile.

### Tecnica naive avanzata

- Utilizzare costrutti come `#ifdef` e `-D` (in C)
- Usare librerire di logging (con messaggi differenziati)
- Usare asserzioni: possono essere viste come oracoli interni al codice

### Dump di memoria

Scrivere su un file il contenuto intero della memoria.

Non richiede modifica del codice, ma è spesso difficile per la differenza tra la rappresentazione astratta dello stato (legata alla strutture dati del linguaggio utilizzato) e la rappresentazione fornita dallo strumento.

### Debugging simbolico

Gli statdi intermedi sono produtti usando una rappresentazione copatibile con quella del linguaggio usato.
Gli stat sono rappresentanti come strutture dati e valori ad essi associati.
I debugger simbolici forniscono ulteriori strumenti (_watch_ o _spy monitor_) che permettono di visualizzare il comportamento del programma in maniera selettiva.
È possibile inserire breakpoint e watch su variabili.

È possibile anche scegliere la granularità del passo di esecuzione:
- singolo;
- entrare dentro a una funzione;
- drop/reset del frame.

Inoltre, si può:
- modificare il contenuto di una variabile
- modificare il codice, talvolta. Necessita ricompilazione ma poi si prosegue dal punto in cui ci si era interrotti
- ...

È possibile automatizzare il debugging? 
http://debuggingbook.org/
