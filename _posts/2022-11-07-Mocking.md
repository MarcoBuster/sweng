---
layout: post
title: "[10] Mocking"
date:   2022-11-07 14:30:00 +0200
toc: true
---

# Mocking

Il mocking è una tecnica di test.

<!-- Introduzione da scrivere (slide 75) -->

[Link consigliato](http://xunitpatterns.com/Test%20Double.html)

## Tipi di oggetti mockati

### Dummy objects

Oggetti _"stupidi"_ che sono passati in giro ma non vengono veramente usati. 

```java
@Test 
public void testDummy() {
    MyClass dummy = ??;

    List<MyClass> SUT = new ArrayList<MyClass>();
    
    SUT.add(dummy);

    assertThat(SUT.size()).isEqualTo(1);
}
```

### Stub objects
Oggetti che forniscono risposte preconfezionate alle sole chiamate fatte durante il testing.

```java
@Test
public void testConStub() {
    MyClass stub = ??;
    MyList<int> SUT = new MyList<int>();

    SUT.add(stub.getValue(0));  // deve ritornare 4
    SUT.add(stub.getValue(1));  // deve ritornare 7
    SUT.add(stub.getValue(1));  // deve ritornare 3
    res = SUT.somma();
    assertThat(res).isEqualTo(14);
}
```

### Mock objects
Oggetti che instrumentano e controllano le chiamate.
```java
@Test
public void testConMock() {
    MyClass mock = ??;

    MyList<int> SUT = new MyList<int>();
    res = SUT.somma(mock);

    assertThat(res).isEqualTo(14);
    // assert che getValue è stata chiamata 3 volte
    // prima una volta con parametro 0 e poi...
}
```

### Spy objects
Oggetti che instrumentano e controllano le chiamate di oggetti reali (di cui possono usare i metodi e lo stato).
```java
@Test
public void testConSpy() {
    MyClass spy = ??;
    
    <!-- finire di copiare -->
}
```

### Fake objects

Oggetti che implementano il DOC ma usando qualche scorciatoia, in maniera non realistica o non installabile.
Per esempio si può utilizzare un database in memoria piuttosto che un database reale. 
È una soluzione inefficiente per casi di dimensione significativa.

## Mockito

```java
@Test
public void testDummy() {
    MyClass dummy = mock(MyClass.class);
    // ...
}
```

```java
@Test
public void testConStub() {
    MyClass stub = mock(MyClass.class);
    when(stub.getValue(0)).thenReturn(4);
    when(stub.getValue(1)).thenReturn(7, 3);
    // ...

    // verifica che sul mock sono state chiamate 1 volta mock.getValue con parametro 0
    io.verify(mock).getValue(0);
    // ... 2 volte ... parametro 1
    io.verify(mock, times(2)).getValue(1);
}
```

### Stubbing
```java
when(mockedObj.methodname(args)).thenXXX(values);
```
- args: values | matchers | argumentCaptor
- matchers: anyInt() | argThat(is(closeTo(1.0, 0.001)))
- thenXXX: thenReturn | thenThrows | thenAnswer | thenCallRealMethod
- values: (codice sotto): sembra uguale ma quella prima non funziona quando metodi ritornano void
```java
doXXX(values).when(mockedObj).methodname(args)
```

### Verifying
Per verificare la occorrenza di una chiamata con certi parametri possiamo fare
```java
verify(mockedclass, howmany).methodname(args)
```
- `howmany` 
<!-- troppa roba da copiare dopo --->

### Esempio di testing con pattern <big>O</big>BSERVER (PULL)

```java
@Test
void modelTest {
    // setup
    Model model = new Model();
    Observer obs = mock(Observer.class);
    Observer obs1 = mock(Observer.class);

    // exercise
    model.addObserver(obs);
    model.addObserver(obs1);
    model.setTemp(42.0, scale);

    // verify
    verify(obs).update(eq(model), eq("42.0"));
    verify(obs1).update(eq(model), eq("42.0"));
}
```

alto esempio:

```java
@Test
void observerTest {
    abstract class MockObservableIModel extends Observable implements Model {};
    MockOBservableIModel model = mock(MockObservableIModel.class);
    when(model.getTemp()).thenReturn(42.42);

    observer.update(model, null);

    verify(model).getTemp();
    assertThat(val).isCloseTo(42.42, Offset.offset(.01));
}
```