---
layout: post
title: "[10] Mocking"
date: 2022-11-07 14:30:00 +0200
toc: true
---

# Four-Phase Test

_Introduzione che mi sembra utile fare, dal link che ha consigliato anche il prof [http://xunitpatterns.com](http://xunitpatterns.com/)_  
Come strutturiamo la nostra logica di test per rendere evidente ciò che stiamo testando?

Ogni test è strutturato in quattro parti distinte eseguite in sequenza. 
È buona pratica progettare ogni test in modo che abbia quattro fasi distinte che
vengono eseguite in sequenza: il set up, l'exercise SUT, la verifica dei risultati e il teardown.

- **SET UP**: prima fase, durante la quale si inizializza tutto il necessario affinché il SUT esibisca il comportamento atteso,
  nonché tutto ciò che è necessario mettere in atto per poter osservare il risultato effettivo
  (ad esempio, creare i vari Test Double).
- **EXERCISE**: seconda fase, durante la quale si interagisce con il SUT.
- **VERIFY**: terza fase, durante la quale si fa tutto il necessario per determinare se il risultato atteso è stato ottenuto o meno
  (asserzioni di vario tipo).
- **TEARDOWN**: quarta fase, fase di pulizia atta a riportare l'ambiente nello stato in cui è stato trovato.

![10_four-phase-test.png](../assets/10_four-phase-test.png)

### Why We Do This
Chi legge il test deve essere in grado di determinare rapidamente quale comportamento il test sta verificando. 
Può essere molto confusionario quando vengono invocati diversi metodi del SUT atti a fare cose diverse.
Identificando chiaramente le quattro fasi, è molto più facile capire l'intento del test.

Inoltre, bisogna evitare la tentazione di testare più funzionalità possibili in un unico metodo di test,
perché ciò può portare a test poco leggibili e a una logica di test troppo complessa. Anzi, l'ideale è avere 
molti metodi di test piccoli che testino una singola funzionalità.
L'uso di commenti per contrassegnare le divisione di un test in quattro fasi è una buona fonte di autodisciplina, 
in quanto rende molto evidente quando i nostri test non testano una singola funzionalità (soprattutto le fasi di exercise e verify)

Certo, i test possono funzionare anche se testano più funzionalità, ma forniranno una minore localizzazione delle anomalie 
rispetto a un gruppo di test indipendenti che testano singole funzionalità. 

# Mocking and Test Double

Come verificare la logica in modo indipendente quando il codice da cui dipende è inutilizzabile? Come possiamo evitare i test lenti? 
**Sostituiamo un componente da cui dipende il SUT con un "equivalente specifico per il test".**

A volte è semplicemente difficile testare il **system under test** (SUT) perché dipende da altri componenti che non possono essere utilizzati 
durante il testing. Ciò può avvenire perché non sono disponibili, non restituiscono i risultati necessari per il test o perché la loro 
esecuzione avrebbe effetti collaterali indesiderati. In altri casi, la nostra strategia di test richiede un maggiore controllo o visibilità 
del comportamento interno del SUT.

Quando si scrive un test in cui non si può (o si sceglie di non) usare il vero componente da cui si è dipendenti (**DOC depended-on component**),
lo si può sostituire con un Test Double. **Test Double** è un termine generico per indicare un qualunque oggetto con cui si sostituisce 
un oggetto reale a scopo di test. Il Test Double non deve comportarsi esattamente come il DOC reale: deve solo fornire le stesse API
in modo che la sua presenza risulti essere trasparente al SUT.

Quando l'industria cinematografica vuole filmare qualcosa che è potenzialmente pericoloso per l'attore protagonista, 
assume una "controfigura" per prendere il posto dell'attore nella scena. La controfigura è un individuo altamente qualificato,
in grado di soddisfare i requisiti specifici della scena. Magari non è in grado di recitare, ma sa come cadere da grandi altezze, 
schiantarsi con un'auto o qualsiasi altra cosa sia richiesta dalla scena. La somiglianza della controfigura con l'attore dipende 
dalla natura della scena. Di solito si può fare in modo che qualcuno che assomiglia vagamente all'attore nella statura possa prendere
il suo posto.

Ai fini del test, possiamo sostituire il DOC (non il SUT!) con il nostro equivalente della "controfigura": il Test Double. 
Durante la fase di set up del test, sostituiamo il vero DOC con il Test Double. 
A seconda del tipo di test che stiamo eseguendo, possiamo codificare il comportamento del Test Double. Quando il SUT 
interagisce con il Test Double, non si accorgerà di nulla e ci permetterà di rendere possibili test che sembravano impossibili.

Naturalmente, per poter utilizzare qualsiasi forma di Test Double, dobbiamo avere un modo per sostituire un DOC reale 
con un Test Double.

Indipendentemente da quale variante di Test Double si scelga di utilizzare, occorre tenere presente che non è 
necessario implementare l'intera interfaccia del DOC. Forniremo solo le funzionalità necessarie per il nostro 
particolare test. Infatti si possono anche costruire Test Double diversi per test diversi che coinvolgono lo stesso DOC.

Possiamo avere diversi tipi di Test Double come possiamo vedere dall'immagine affianco.

### Dummy Object

A volte per poter testare un oggetto (il SUT) è necessario fare in modo che si trovi in un determinato stato.
Per far si che il SUT sia nello stato corretto può essere necessario anche chiamare alcuni suoi metodi.
Questi spesso prendono come argomenti oggetti che vengono memorizzati in variabili d'istanza solo per un uso successivo:
questi oggetti (o almeno alcuni di questi oggetti) non vengono mai utilizzati nel codice che stiamo testando e quindi
ci troviamo a doverli creare solo per conformarci alla firma di qualche metodo che dobbiamo chiamare per portare la SUT
nello stato giusto. La costruzione di questi oggetti può essere non banale e aggiunge una complessità non necessaria al test.

In questi casi, si può passare un Dummy Object come argomento, eliminando la necessità di costruire un oggetto reale:
i **dummy object** sono quindi una forma degenerata di Test Double, esistono solo per poter essere passati da un metodo 
all'altro; non vengono mai utilizzati.

Si noti che un Dummy Object non è la stessa cosa di un Null Object. Un Dummy Object non viene utilizzato dal SUT, 
quindi il suo comportamento è irrilevante. Al contrario, un Null Object viene utilizzato dal SUT ma è progettato 
per non fare nulla. È una distinzione piccola ma molto importante.

<style>
td, tr {
   border: none!important;
}
</style>
<table>
<tbody>
<tr>
<td>Senza Mokito</td>
<td>Con Mokito</td>
</tr>
<tr>
<td>

```java
@Test 
public void testDummy() {
    MyClass dummy = ??;

    List<MyClass> SUT = new ArrayList<MyClass>();
    
    SUT.add(dummy);

    assertThat(SUT.size()).isEqualTo(1);
}
```
</td>
<td>

```java
@Test 
public void testDummy() {
    MyClass dummy = mock(MyClass.class);
    
    List<MyClass> SUT = new ArrayList<MyClass>();
    
    SUT.add(dummy); 
    
    assertThat(SUT.size()).isEqualTo(1);
} 
```
</td>
</tr>
</tbody>
</table>

### Stub Objects

Come detto, a volte risulta, essere difficile testare un SUT perché il suo comportamento dipende da quelli che sono input 
provenienti da altri componenti software (DOC). Per testare quindi il SUT in modo indipendente dobbiamo sostituire
questi oggetti reali con oggetti che siano test-specific: oggetti che immettano gli input indiretti desiderati nel SUT.

Questi oggetti test-specific prendono il nome di **Test Stub**: sostituiscono un componente reale, da cui 
dipende il SUT, e forniscono risposte (input) preconfezionati alle chiamate fatte durante il testing. Ciò consente al 
test di forzare il SUT a seguire determinati percorsi che altrimenti non avrebbe potuto eseguire.

<style>
td, tr {
   border: none!important;
}
</style>
<table>
<tbody>
<tr>
<td>Senza Mokito</td>
<td>Con Mokito</td>
</tr>
<tr>
<td>

```java
@Test
public void testConStub() {
    MyClass stub = ??;
    MyList<int> SUT = new MyList<int>();

    SUT.add(stub.getValue(0));  // deve ritornare 4
    SUT.add(stub.getValue(1));  // deve ritornare 7
    SUT.add(stub.getValue(1));  // deve ritornare 3
    res = SUT.somma();
    assertThat(res).isEqualTo(14);
}
```
</td>
<td>

```java
@Test
public void testConStub() {
    MyClass stub = mock(MyClass.class);
    when(stub.getValue(0)).thenReturn(4);
    when(stub.getValue(1)).thenReturn(7, 3);
    
    MyList<int> SUT = new MyList<int>();
    SUT.add(stub.getValue(0));  // deve ritornare 4
    SUT.add(stub.getValue(1));  // deve ritornare 7
    SUT.add(stub.getValue(1));  // deve ritornare 3
        
    res = SUT.somma();
    
    assertThat(res).isEqualTo(14);
}
```
</td>
</tr>
</tbody>
</table>

### Mock Object

Quando il comportamento del sistema sotto test (SUT) include azioni che non possono essere osservate attraverso la sua
interfaccia, ma che anzi sono osservate da/su altri componenti software, chiamiamo tali azioni
output indiretti del SUT. Gli output indiretti possono essere chiamate di metodi o funzioni a un altro componente,
record inseriti in un database, record scritti su un file o cosi via. La verifica dei comportamenti degli output indiretti del SUT
richiede punti di osservazione appropriati: per implementare il punto di osservazione si utilizzano spesso oggetti Mock,
che intercettano gli output indirette del SUT e permettono di confrontarle con i valori attesi.

Quindi un Mock object è utilizzato per instrumentare e controllare le chiamate fatte dal SUT.
In genere, l'oggetto Mock include anche la funzionalità di uno stub di test, nel senso che deve restituire valori
al SUT, ma l'enfasi è sulla verifica delle chiamate effettuate dal SUT. Pertanto, un Oggetto Mock è diverso da un Test 
Stub o almeno viene usato in modo fondamentalmente diverso.

<style>
td, tr {
   border: none!important;
}
</style>
<table>
<tbody>
<tr>
<td>Senza Mokito</td>
<td>Con Mokito</td>
</tr>
<tr>
<td>

```java
@Test
public void testConMock() {
    MyClass mock = ??;
    
    MyList<int> SUT = new MyList<int>();
    
    res = SUT.somma(mock);
    
    assertThat(res).isEqualTo(14);
    // assert che getValue è stata chiamata 3 volte
    // prima una volta con parametro 0 e poi...
}
```
</td>
<td>

```java
@Test 
public void testConMock() {
     MyClass mock = mock(MyClass.class);
     
     when(mock.getValue(0)).thenReturn(4); 
     when(mock.getValue(1)).thenReturn(7,3);

     MyList<int> SUT = new MyList<int>();

     res = SUT.somma(mock);
     
     assertThat(res).isEqualTo(14); 
     InOrder io = inOrder(mock); 
     io.verify(mock).getValue(0); 
     io.verify(mock, times(2)).getValue(1);
} 
```
</td>
</tr>
</tbody>
</table>

## Spy objects

Un altro modo per implementare punti di osservazione che controllino e instrumentino le chiamate effettuate dal SUT
su determinati DOC sono gli Spy object: a differenza dei mock questi sono costruiti a partire da oggetti reali.

Successivamente alla fase d'interazione con il SUT (exercise), durante la fase di verifica dei risultati (verify), il test 
confronta le chiamate effettuate dal SUT sul Test Spy con il comportamento desiderato (expected).

<style>
td, tr {
   border: none!important;
}
</style>
<table>
<tbody>
<tr>
<td>Senza Mokito</td>
<td>Con Mokito</td>
</tr>
<tr>
<td>

```java
@Test
public void testConSpy() {
        MyClass spy = ??;

        MyList<int> SUT = new MyList<int>();

        res = SUT.somma(spy);

        assertThat(set).isEqualTo(14);
        //assert che getValue è stata chiamata 3 volte
        //prima una volta con parametro 0 e poi...    
        }
```
</td>
<td>

```java
@Test 
public void testConSpy() {
     MyClass spy = spy(new MyClass());

     MyList<int> SUT = new MyList<int>();

     res = SUT.somma(spy);
     
     assertThat(res).isEqualTo(14); 
     InOrder io = inOrder(spy); 
     io.verify(spy).getValue(0); 
     io.verify(spy, times(2)).getValue(1);
} 
```
</td>
</tr>
</tbody>
</table>



### Fake Object

Oggetti che implementano davvero le funzionalità del DOC ma usando una qualche scorciatoia, dunque in maniera non 
realistica o non installabile: database in memoria invece di database reale, soluzioni inefficienti, parti di codice 
open source utilizzabili nella fase di testing ma non in quella di produzione, ecc... .


## Mokito

Mockito è un framework di testing open source per Java rilasciato sotto la licenza MIT. 
Il framework facilita di gran lunga la creazione di oggetti test double permettendo quindi di concentrarsi maggiormente
nella scrittura dei test. Rende inoltre il tutto anche molto più leggibile.

### Stubbing
```java
when(mockedObj.methodname(args)).thenXXX(values);
```
- args: values | matchers | argumentCaptor
- matchers: anyInt() | argThat(is(closeTo(1.0, 0.001)))
- thenXXX: thenReturn | thenThrows | thenAnswer | thenCallRealMethod
- values: (codice sotto): sembra uguale ma quella prima non funziona quando metodi ritornano void
```java
doXXX(values).when(mockedObj).methodname(args)
```
sembra uguale ma quella di prima non funziona con metodi che ritornano void.
### Verifying
Per verificare la occorrenza di una chiamata con certi parametri possiamo fare
```java
verify(mockedclass, howmany).methodname(args)
```
- _howmany_ : times(n) | never | atLeast(n) | atMost(n)

Per verificare l'ordine delle occorrenze delle chiamate
```java
InOrder inO = inOrder(mock1, mock2, ...)
inO.verify...
```
È possibile anche catturare un parametro per farci sopra asserzioni
```java
ArgumentCaptor<Person> arg = ArgumentCaptor.forClass(Person.class);
verify(mock).doSomething(arg.capture());
assertEquals("John", arg.getValue().getName());
```


### Esempio di testing con pattern <big>O</big>BSERVER (PULL)

```java
@Test
void modelTest {
    // setup
    Model model = new Model();
    Observer obs = mock(Observer.class);
    Observer obs1 = mock(Observer.class);

    // exercise
    model.addObserver(obs);
    model.addObserver(obs1);
    model.setTemp(42.0, scale);

    // verify
    verify(obs).update(eq(model), eq("42.0"));
    verify(obs1).update(eq(model), eq("42.0"));
}
```

test di un observer con un modello non generico ma di cui ho solo interfaccia di cui fornisco una versione dummy:

```java
@Test
void observerTest {
    abstract class MockObservableIModel extends Observable implements Model {};
    MockOBservableIModel model = mock(MockObservableIModel.class);
    when(model.getTemp()).thenReturn(42.42);

    observer.update(model, null);

    verify(model).getTemp();
    assertThat(val).isCloseTo(42.42, Offset.offset(.01));
}
```