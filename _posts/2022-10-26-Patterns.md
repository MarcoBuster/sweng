---
layout: post
title: "[09] Patterns"
date:   2022-10-26 14:30:00 +0200
toc: true
---

# Patterns

Il pattern è ........
L'idioma è ....

I meta patterns identificano due elementi base:
- __HookMethod__: un metodo astratto che determina il comportamento specifico nelle sottoclassi. È un _punto caldo_ in cui si può intervenire per personalizzare, adattare lo schema.
- __TemplateMethod__: pmetodo che coordina generalmente più hook metodo. È l'_elemento freddo_ di inviariabilità del pattern.

Come si realizzano l'_hook_ e il _template_? 
- __Unification__: nella stessa classe. L'_hook_ è astratto, il _template_ è concreto.
- __Connection__: hook e template sono in classi separate indicate ripsettivamente come _hook class_ e _template class_ tra di loro collegate da un'assocazione.
- __........__

## <big>S</big>INGLETON

Cerca di definire il concetto di UNO oggetto / UNA istanza in linguaggi in cui vengono fornite solo classi.
Si vuole rendere la classe responsabile del fatto che non può esistere più di una istanza.

```java
public class Singleton {
    /* costruttore privato o comunque non pubblico */
    protected Singleton() { ... }

    /* salvo l'istanza per usarla dopo */
    private static Singleton instance = null;

    /* metodo statico */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void sampleOp() { ... }
}
```

Un problema di questo pattern è l'accesso concorrente.
Al primo accesso di `getInstance` è possibile che due processi concorrenti la chiamino generando due istanze. 
Una soluzione sarebbe utilizzare la keyword `synchronized` di Java, ma rallenterebbe tutto il sistema (per l'acquire del lock) portando vantaggi solo alla prima chiamata.

... discorso java 5 ...

### Idioma Java

```java
public enum MySingleton {
    INSTANCE;

    public void sampleOp() { ... }
}

MySingleton.INSTANCE.sampleOp();
```

È thread safe, ma a prima vista è molto meno chiaro dell'approccio precedente.

## <big>I</big>TERATOR

Fornisce un modo per accedere agli elementi di un oggetto aggregatore in maniera sequenziale senza esporre la rappresentazione interna.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /* aggiunta funzionale opzionale */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

Per esempio, possiamo migliorare il progetto delle carte da così:
```java
Iterator<Card> cardIterator = deck.getCards();
while (cardIterator.hasNext()) {
    Card card = cardIterator.next();
    System.out.println(card.getSuit());
}
```

a così:

```java
for (Card card : deck) {
    System.out.println(card.getSuit());
}
```

È più chiaro, è palese che `card` sia read-only ed è supportato dall'IDE.

## <big>C</big>HAIN OF <big>R</big>ESPONSIBILITY
Permette di definire una catena di potenziali gestori di una richiesta di cui non sappiamo a priori chi sarà in grado di gestirla effettivamente.

## <big>F</big>LY<big>W</big>EIGHT

Serve a gestire una collezione di oggetti immutabili assicurandone l'unicità.

Quando le istanze equivalenti sono fortemente condivise all'interno del prograllam diventano auspicabili sia immutabili che unicità.
A differenza del <big>S</big>INGLETON, è difficile definire a priori quante istanze ci sono.

```java
public class Card {
    private static final Card[][] CARDS = new Card[Suit.values().length][Rank.values().length];

    static {
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                CARDS[suit.ordinal()][rank.ordinal()] = new Card(rank, suit);
            }
        }
    }

    public static Card get(Rank pRank, Suit pSuit) {
        return CARDS[pSuit.ordinal()][pRank.ordinal()];
    }
}
```

È un po' inefficiente perché alla prima computazione inizializza tutti gli oggetti, perdendo tempo e sprecando potenzialmente spazio.

## <big>D</big>ELEGATION / <big>S</big>TRATEGY

Fa parte della famiglia "gang of four" (GoF). 
Definisce una famiglia algoritmi e li rende (tramite _encapsulation_) tra di loro intercambiabili.

<!-- inserire immagine da slide 67 -->

## <big>O</big>BSERVER

Nasce per risolvere il probelam delle pairwise dependencies. 
Estraendo la parte comune (lo _stato_) lo mettiamo in un oggetto a parte (_subject_) che verrà osservato dagli altri (_observer_).
Ho quindi $$n$$ classi che osservano lo stato di una classe e reagiscono ad ogni cambiamento di stato di quest'ultima.

Il polling non va bene: spreca risorse. Gli observer si registrano al subject che li informa se ci sono cambiamenti: architettura __event-driven__.

È una situazione talmente comune che in Java erano presenti delle classi (ora deprecate in quanto non _thread-safe_) per realizzare questo pattern: `java.util.Observer` e `java.util.Observable`.

<!-- inserire immagine da slide 71 -->

### push
```java
// Observable
@Override
public void notifyObservers() {
    for (Observer observer : observers) {
        observer.update(null, state);
    }
}

// Observer
@Override
public void update(Observable model, Object state) {
    if (state instanceof Integer intValue) {
        doSomethingOn(intValue);
    }
}
```

Il problema di questo approccio è che gli observer sono solitamente interessati a un piccolo sottoinsieme dello stato, quindi inviarlo tutto interamente potrebbe creare problemi.

### pull

```java
// Observable
@Override
public void notifyObservers() {
    for (Observer observer : observers) {
        observer.update(this, null);
    }
}

// Observer
@Override
public void update(Observable model, Object state) {
    if (model instanceof ConcreteObservable cModel) {
        doSomethingOn(cModel.getState());
    }
}
```

Passando l'observable, quest'ultimo potrebbe offrire dei metodi per rendere disponibile solo dei sottoinsiemi dello stato.

## <big>A</big>DAPTER

Per esempio, in un ambito di sviluppo COTS (Component Off The Shelf) riutilizziamo tanti componenti presi dal mercato.
I componenti non sono direttamente compatibili: dobbiamo creare la _"colla"_ che lega i componenti tra loro per soddisfare le specifiche del nostro sistema.

Sto facendo evolvere incrementalmente un sistema (legacy?) per cui mi trovo nella situazione di avere alcuni componenti vecchi che (provvisoriamente) devono collaborare con componenti nuovi.

Ci sono due versioni di questo pattern. 

### Class adapter
```java
public class Adapter extends Adaptee implemenets Target {
    @Override
    public void request() {
        this.oldRequest();
    }
}
```

### Object Adapter
Invece che estendere l'`Adaptee`, l'object adapter lo contiene (aggregazione).

```java
public class Adapter implements Target {
    private final Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        assert adaptee != null;
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.oldRequest();
    }
}
```

### Confronto
- Il Class Adapter ha la possibilità di accedere agli atttributi protetti di `Adaptee`
- L'Object Adapter nasconde i metodi che non reimplementiamo
- Il Class Adapter è più flessibile perché """unisce""" i metodi dell'`Aqpbdapter` e dell'`Adaptee` quindi è sostituibile
    - ma è sempre vero? se `adapter` reimplementa lo stesso metodo ma cambia la funzionalità, è casino
- Uso della memoria: con Class Adapter ho un oggetto unico, nell'Object Adapter ho due oggetti distinti che sui grandi numeri può creare casino
- Con l'Object Adapter posso adattare anche interfacce, con il Class Adapter no. 

<!-- aggiungi roba a slide 100 --> 

## <big>F</big>ACADE
Fornisce un'interfaccia unificata e semplificata a un insieme di interfacce separate.

## <big>C</big>OMPOSITE

Gestire strutture ad albero per rapprseentare gerarchie di parti e insiemi uniformemente.

Il cliente interagisce esclusivamente tramite l'interfaccia `Component`. 
Risulta semplice perché non si deve preoccupare se sta interagendo con un elemento singolo o composito.
Minore possibilità di controllo su che tipo di oggetti possono essere dentro a particolari `Composite`.

Per esempio: negli strumenti da disegno si possono selezionare più oggetti anche diversi e eseguire operazioni comuni (come _sposta_).

### Esempio: Composite Card Source

`CompositeDeck` è un mazzo composto da carte e da mazzi e da insieme di mazzi ecc...

```java
public class CardSourceComp implements CardSource {
    @NotNull private List<CardSource> sources;

    public boolean isEmpty() {
        for (CardSource source : sources) {
            if (!source.isEmpty())
                return false;
            return true;
        }
    }
}
```

## <big>D</big>ECORATOR

Permette di aggiungere nuove funzionalità o caratteristice dinamicamente. 

### Esempio: carte

```java
public class LoggingDeck implements CardSource {
    public Card draw() {
        Card card = cards.pop();
        System.out.println(card);
        return card;
    }
}
```

La soluzione più semplice è creare una classe per ogni possibile decorazione, ma il numero cresce troppo velocemente portando un'enorme duplicazione del codice.

Un'altra soluzione è <big>G</big>OD CLASS: creo una classe unica in tramite degli attributi booleani e switch attualizzo le varie decorazioni.

```java
public class MultiModeDeck implements CardSource {
    boolean logging = false;
    boolean memo = false;

    public void setLogging(boolean status) {
        logging = status;
    }

    public void setMemo(boolean status) {
        memo = status;
    }

    public Card draw() {
        Card card = cards.pop();
        if (logging) System.out.println(card);
        if (memo) ...
        return card; 
    }
}
```

È un anti pattern forse peggiore, perché sembra una soluzione giusta e rapida ma in realtà porta per forza di cose a cambiare design, perché la classe è troppo grande.

### Il vero pattern

L'aggiunta di nuove responsabilità si fa tramite l'aggiunta di nuovi oggetti.


### Esempio: carte 2
```java
public class LoggingDecorator implements CardSource {
    private final CardSource element;

    public LoggingDecorator(CardSource cardSource) {
        element = cardSource;
    }

    public boolean isEmpty() {
        return element.isEmpty();
    }

    public Card draw() {
        Card card = element.draw();
        System.out.println(card);
        return card;
    }
}
```

Possiamo raggruppare i metodi comuni nella classe astratta.

```java
public abstract class Decorator implements CardSource {
    private final CardSource element;

    public Decorator(CardSource element) {
        assert element != null;
        this.element = element;
    }

    @Override
    public Card draw() {
        return element.draw();
    }

    @Override 
    public boolean isEmpty() {
        return element.isEmpty();
    }
}
```

```java
public class LoggingDecorator extends Decorator {
    public LoggingDecorator(CardSource element) {
        super(element);
    }

    @Override
    public Card draw() {
        Card card = super.draw();
        System.out.println(card);
        return card;
    }
}
```
```java
public class MemoDecorator extends Decorator {
    private final List<Card> drawnCards;

    public MemoDEcorator(CardSource element) {
        super(element);
        drawnCards = new ArrayList<>();
    }

    @Override
    public 
    ...
}
```

---

Possiamo creare un'altra versione ancora

```java
public abstract class Decorator implements CardSource {
    @NotNull private final CardSource element;

    public Decorator(@NotNull CardSource element) {
        this.element = element;
    }

    @Override 
    @NotNull
    public Card draw() {
        Card card = element.draw();
        decorationAction(card);
        return card;
    }

    @Override
    public boolean isEmpty() {
        return element.isEmpty();
    }

    protected void decorationAction(@NotNull Card card) {};
}
```

```java
public class LoggingDEcorator extends Decorator {
    public LoggingDecorator(@NotNull CardSource element) {
        super(element);
    }

    @Override
    protected void decorationAction(@NotNull Card card) {
        System.out.println(card);
    }
}
```

