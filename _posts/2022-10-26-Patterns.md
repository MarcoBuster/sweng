---
layout: post
title: "[09] Patterns"
date:   2022-10-26 14:30:00 +0200
toc: true
---

# [Patterns](https://refactoring.guru/)

Parlando di progettazione del software e di buone pratiche è impossibile non parlare di __design patterns__, soluzioni universalmente riconosciute valide a problemi di design ricorrenti: si tratta cioè di strumenti concettuali di progettazione che esprimono un'architettura vincente del software catturando la soluzione ad una famiglia di problemi.

Ad ogni pattern sono associati una serie di __idiomi__, implementazioni del pattern specifiche per un certo linguaggio di programmazione che sfruttano i costrutti del linguaggio per realizzare l'architettura dettata dal pattern.
Durante questa discussione vedremo alcuni idiomi per Java, che talvolta si discosteranno fortemente dalla struttura descritta dai diagrammi UML dei pattern.

Ma attenzione, esistono anche degli __anti-pattern__, soluzioni che _sembrano_ buone ma sono dimostratamente problematiche: dovremo assicurarci di tenerci lontani da questi design truffaldini!

#### Discutere di pattern: i meta-pattern

Prima di iniziare a parlare dei principali pattern che un informatico dovrebbe conoscere, possiamo chiederci come possiamo parlare di pattern: semplice, con dei _meta-patterns_, pattern con cui costruire altri pattern!

Nello specifico, i meta-patterns identificano due elementi base su cui ragionare quando si trattano i pattern:

- __HookMethod__: un "metodo astratto" che, implementato, determina il comportamento specifico nelle sottoclassi; è il _punto caldo_ su cui interveniamo per adattare lo schema alla situazione.

- __TemplateMethod__: metodo che coordina generalmente più HookMethod per realizzare il design voluto; è l'_elemento freddo_ di invariabilità del pattern che ne realizza la rigida struttura.

Ovviamente i metodi _template_ devono avere un modo per accedere ai metodi _hook_ se intendono utilizzarli per realizzare i pattern.
Tale collegamento può essere fatto in tre modi differenti:

- __Unification__: _hook_ e _template_ si trovano nella stessa classe astratta, classe da cui erediteranno le classi concrete per implementare i metodi _hook_ e, di conseguenza, il pattern; i metodi _template_ sono invece già implementati in quanto la loro struttura non si deve adattare alla specifica applicazione.

{% plantuml style="width: 30%" %}
class TemplateHookClass {
  {abstract} hookMethod()
  templateMethod()
}
{% endplantuml %}

- __Connection__: _hook_ e _template_ sono in classi separate, indicate rispettivamente come _hook class_ (astratta) e _template class_ (concreta), collegate tra di loro da un'aggregazione: la classe template contiene cioè un'istanza della classe hook, in realtà un'istanza della classe concreta che realizza i metodi hook usati per implementare il pattern.

{% plantuml style="width: 25%" %}
class TemplateClass {
  templateMethod()
}
class HookClass {
  {abstract} hookMethod()
}
TemplateClass o--> HookClass 
{% endplantuml %}

- __Recursive connection__: come nel caso precedente _hook_ e _template_ sono in classi separate, ma oltre all'aggregazione tali classi sono qui legate anche da una relazione di generalizzazione: la classe template dipende infatti dalla classe hook.

{% plantuml style="width: 30%" %}
class TemplateClass {
  templateHookMethod()
}
class HookClass {
  {abstract} templateHookMethod()
}
TemplateClass --|> HookClass
TemplateClass o--> HookClass
{% endplantuml %}

Vedremo a quale meta-pattern aderiranno i pattern che vediamo. 
A tal proposito,i pattern che vedremo fanno parte dei cosiddetti "__Gang Of Four patterns__", una serie di 23 pattern definiti da Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides; oltre ad averli definiti, questi signori hanno diviso i pattern in tre categorie:

- __Creazionali__: legati alla creazione di oggetti
- __Comportamentali__: legati all'interazione tra oggetti
- __Strutturali__: legati alla composizioni di classi e oggetti

## <big>S</big>INGLETON

Talvolta vorremmo che di un certo oggetto esistesse __una sola istanza__ perché logicamente di tale oggetto non ha senso esistano diverse copie all'interno dell'applicazione (es. diverse istanze della classe Gioco in un sistema che gestisce un solo gioco alla volta).
Tuttavia i linguaggi Object-Oriented gestiscono solo classi con istanze multiple, per cui la realizzazione di questa unicità può rivelarsi più complessa del previsto.

La soluzione consiste nel rendere la classe stessa responsabile del fatto che non può esistere più di una sua istanza: per fare ciò il primo passo è ovviamente quello di _rendere privato il costruttore_, o se non privato comunque non pubblico (conviene metterlo protected in modo da poter creare sottotipi). \
Bisogna però garantire comunque un modo per recuperare l'unica istanza disponibile della classe: si crea dunque il _metodo statico_ `getInstance` che restituisce a chi lo chiama l'unica istanza della classe, creandola tramite il costruttore privato se questa non è già presente.
Tale istanza è infatti memorizzata in un _attributo statico_ della classe stessa, in modo così da poterla restituire a chiunque ne abbia bisogno.

{% plantuml %}
class Singleton {
    + {static} instance : Singleton
    # Singleton()
    + {static} Singleton getInstance()
    + sampleOp()
}
{% endplantuml %}

Con queste accortezze è possibile creare una classe Singleton simile a questa:

```java
public class Singleton {
    /* costruttore privato o comunque non pubblico */
    protected Singleton() { ... }

    /* salvo l'istanza per usarla dopo */
    private static Singleton instance = null;

    /* metodo statico */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void metodoIstanza() { ... }
}
```

Tuttavia, per come lo abbiamo scritto questa classe non assicura di non creare più di un'istanza di sé stessa, in quanto non prende in considerazione la __concorrenza__.
Se due processi accedono in modo concorrente al metodo `getInstance`, entrambi potrebbero eseguire il controllo sul valore nullo dell'istanza ed ottenere un successo in quanto l'istanza non è ancora stata assegnata al relativo attributo statico nell'altro processo: si ottiene dunque che uno dei due processi ha accesso ad una propria istanza privata, cosa che distrugge completamente il nostro pattern!

Una prima soluzione sarebbe di mettere un lock sull'esecuzione del metodo anteponendovi la direttiva `@Synchronized`: tuttavia, tale approccio comporterebbe un notevole calo di prestazioni del sistema portando vantaggi unicamente alla prima chiamata. \
Una soluzione molto più efficiente (non possibile però fino a Java 5) è invece quella che prevede di avere un _blocco sincronizzato_ di istruzioni posto all'interno del ramo in cui si pensa che l'istanza sia nulla in cui ci si chiede se effettivamente l'istanza è nulla e solo allora si esegue il costruttore; la presenza del doppio controllo assicura che non vi siano squilibri dovuti alla concorrenza, mentre sincronizzare solamente un blocco e non l'intero metodo fa sì che il calo di prestazioni sia sentito solamente durante le prime chiamate concorrenti.

### Idioma Java

Fortunatamente si è sviluppato per il linguaggio Java un idioma molto semplice per il Singleton, in cui al posto di usare una classe per definire l'oggetto si usa un __enumerativo__ con un unico valore, l'istanza.
Ciascun valore di tali oggetti è infatti trattato nativamente da Java proprio come un Singleton: viene creato al momento del suo primo uso, non ne esiste più di una copia, e chiunque vi acceda accede sempre alla medesima istanza.
La possibilità di creare attributi e metodi all'interno degli `enum` completa il quadro.

```java
public enum MySingleton {
    INSTANCE;

    public void metodoIstanza() { ... }
}

MySingleton.INSTANCE.sampleOp();
```

Si tratta inoltre di un approccio "thread safe", ovvero che lavora già bene con la concorrenza; l'unico svantaggio è che, se non si conosce l'idioma, a prima vista questa soluzione risulta molto meno chiara rispetto all'approccio precedente.

## <big>I</big>TERATOR

Talvolta gli oggetti che definiamo fanno da __aggregatori__ di altri oggetti, contenendo cioè una collezione di questi su cui poi fare particolari operazioni: in questi casi è molto probabile che vorremo poter iterare sui singoli elementi aggregati, ma senza esporre la rappresentazione interna usata per contenerli.

Proprio per risolvere questo tipo di problematiche nasce il pattern Iterator: esso consiste nella creazione di una classe `ConcreteIterator` che abbia accesso alla rappresentazione interna del nostro oggetto e esponga i suoi elementi in modo sequenziale tramite i metodi `next()` e `hasNext()`; dovendo accedere alla rappresentazione, molto spesso tale iteratore si realizza come una _classe interna anonima_.

Java supporta largamente il pattern Iterator, a tal punto che nella libreria standard esiste un'interfaccia generica per gli iteratori, `Iterator<E>`: all'interno di tale interfaccia sono definiti, oltre ai metodi di cui sopra, il metodo `remove()`, normalmente non supportato in quanto permetterebbe di modificare la collezione contenuta dalla classe, e il metodo `forEachRemaining()`, che esegue una data azione su tutti gli elementi ancora non estratti dell'iteratore.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /* aggiunta funzionale opzionale */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

Esiste inoltre un'interfaccia che l'oggetto iterabile può implementare, `Iterable<E>`: essa richiede solamente la presenza di un metodo `iterator()` che restituisca l'iteratore concreto, e una volta implementata permette di utilizzare il proprio oggetto aggregatore all'interno di un costrutto foreach.

{% plantuml style="width:60%" %}
interface Iterable<T> << interface >> {
    + {abstract} Iterator<T> iterator()
}
interface Iterator<T> << interface >> {
    + {abstract} boolean hasNext()
    + {abstract} T next()
    + void remove()
    {method} ...
}
Iterable .> Iterator
class ConcreteIterable implements Iterable {
    + Iterator<T> iterator()
}
class ConcreteIterator implements Iterator {
    + boolean hasNext()
    + T next()
}
ConcreteIterable .> ConcreteIterator
hide empty fields
{% endplantuml %}

Così, per esempio, possiamo passare dal seguente codice:

```java
Iterator<Card> cardIterator = deck.getCards();
while (cardIterator.hasNext()) {
    Card card = cardIterator.next();
    System.out.println(card.getSuit());
}
```

... a quest'altro:

```java
for (Card card : deck) {
    System.out.println(card.getSuit());
}
```

Oltre ad essere più stringato il codice è significativamente più chiaro, rendendo palese che la singola `card` sia read-only.

## <big>C</big>HAIN OF <big>R</big>ESPONSIBILITY

Talvolta nei nostri programmi vorremmo definire una gestione "a cascata" di una certa richiesta. Pensiamo per esempio a una serie di regole anti-spam: all'arrivo di una mail la prima regola la esamina e si chiede se sia applicabile o meno; in caso affermativo contrassegna la mail come spam, altrimenti _la passa alla prossima regola_, che a sua volta farà lo stesso test passando il controllo alla terza in caso negativo, e così via.
Abbiamo cioè un _client_ in grado di fare una richiesta, e una __catena di potenziali gestori__ di cui non sappiamo a priori chi sarà in grado di gestirla effettivamente.

Il pattern Chain of Responsibility risolve il disaccoppiamento tra client e gestore _concatenando i gestori_.
Esso prescrive la creazione di un'interfaccia a cui tutti i gestori devono aderire, contenente solo la dichiarazione di un metodo `evaluate` che implementa la logica descritta prima: si stabilisce se si può gestire la richiesta, e se non si può si chiama lo stesso metodo su _un altro gestore_ ottenuto come parametro al momento della creazione.

{% plantuml style="width: 100%" %}
class PokerHand {
    + HandRank getRank()
}
interface ChainedHandEvaluator << interface >> {
    + {abstract} handEvaluator()
}
PokerHand -> ChainedHandEvaluator
ChainedHandEvaluator "0..1" o-> "0..1" ChainedHandEvaluator : next
class HighCardEvaluator implements ChainedHandEvaluator {
    + HighCardEvaluator(ChainedHandEvaluator)
    + handEvaluator()
}
note left of HighCardEvaluator::"handEvaluator()" 
    if (can_handle) { 
        return do_it(); 
    } else { 
        return next.handEvaluator(); 
    }
end note
hide empty fields
{% endplantuml %}

In questo modo all'interno del client è sufficiente creare una vera e propria catena di gestori e chiamare il metodo `evaluate` del primo: si noti che l'ordine in cui vengono assemblati tali gestori conta, in quanto la valutazione procede sequenzialmente.

```java
public interface Gestore {

    /* Il tipo di ritorno dipende dal campo applicativo */
    public ??? evaluate(); 

}

public class Client {

    private Gestore evaluator = 
        new GestoreConcreto1(
            new GestoreConcreto2(
                new GestoreConcreto3(null)));

    public void richiesta() {
        evaluator.evaluate();
    }

}
```

## <big>F</big>LY<big>W</big>EIGHT

Talvolta ci troviamo in una situazione simile a quella che aveva ispirato il pattern Singleton: abbiamo una __serie di oggetti immutabili fortemente condivisi__ all'interno del programma e per motivi di performance e risparmio di memoria vorremmo che _non esistano istanze diverse a parità di stato_.
Se due client devono usare un'istanza con lo stesso stato vorremmo cioè non usino ciascuno un'istanza duplicata ma proprio la _stessa istanza_: essendo le istanze immutabili, tale condivisione non dovrebbe infatti creare alcun tipo di problema.

Il pattern FlyWeight serve a gestire una collezione di oggetti immutabili assicurandone l'unicità: esso consiste nel rendere privato il costruttore e __costruire tutte le istanze a priori con un costruttore statico__, salvandole in una lista privata.
I client possono dunque richiedere una certa istanza con un metodo `get` specificando lo stato dell'istanza desiderata: in questo modo, a parità di richiesta verranno restituite le stesse identiche istanze.

Abbiamo visto un'applicazione di questo pattern durante i laboratori parlando di `Card`:

```java
public class Card {
    private static final Card[][] CARDS = new Card[Suit.values().length][Rank.values().length];

    static {
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                CARDS[suit.ordinal()][rank.ordinal()] = new Card(rank, suit);
            }
        }
    }

    public static Card get(Rank pRank, Suit pSuit) {
        return CARDS[pSuit.ordinal()][pRank.ordinal()];
    }
}
```

A differenza del pattern Singleton è difficile definire a priori quante istanze ci sono: abbiamo un'istanza per ogni possibile combinazione dei valori degli attributi che compongono lo stato.
Proprio per questo motivo il pattern può risultare un po' inefficiente per oggetti con rappresentazioni grandi: alla prima computazione vengono infatti inizializzati _tutti_ gli oggetti, perdendo un po' di tempo e sprecando potenzialmente spazio se non tutte le istanze saranno accedute.

## <big>N</big>ULL<big>O</big>BJECT

Spesso nei nostri programmi avremo bisogno di utilizzare valori "nulli": pensiamo per esempio al termine di una Chain of Responsibilities, dove per fermare la catena di chiamate dobbiamo dare un valore nullo al `next` dell'ultimo gestore.
In generale, a una variabile che indica un riferimento ad un oggetto possiamo assegnare il valore speciale `null` per indicare che essa _non punta a nulla_.

Il problema sorge però quando a runtime si prova a dereferenziare tale valore e viene sollevata un'eccezione (`NullPointerException` in Java): questa possibilità ci costringe nel codice ad essere sempre molto titubanti sui valori che ci vengono passati, in quanto non possiamo mai assumere che essi puntino ad un valore reale e dunque dobbiamo sempre controllare che non siano nulli.

C'è però da dire che anche con tali accortezze l'utilizzo di `null` è poco carino, in quanto un valore nullo può indicare cose anche molto diverse:

- un errore a runtime
- uno stato temporaneamente inconsistente
- un valore assente o non valido

Ogni volta che si utilizza `null` il codice diventa un po' meno chiaro, e sarebbe necessario disambiguare con commenti o documentazione per spiegare con che accezione tale valore viene usato.
Anche le strategie di gestione del `null` variano drasticamente a seconda del significato assegnato a tale valore: quando non ci sono valori "assenti" e dunque il `null` indica solo un errore è sufficiente controllare che i dati passati non siano nulli con condizioni, asserzioni o l'annotazione `@NotNull`.

{% responsive_image path: assets/09_nullObject-valori-non-assenti.png %}

Quando invece ci sono __valori "assenti"__, ovvero che indicano situazioni particolari (es. il Joker in un mazzo di carte, che non ha né Rank né Suit), la gestione è più complicata.
Se non vogliamo trattarli come `null` per l'ambiguità che tale valore introduce, un'altra opzione è creare un metodo booleano nella classe che restituisce se l'istanza ha il valore nullo (es. `isJoker()`): tuttavia, questo apre le porte a errori da parte dell'utente, che potrebbe dimenticarsi di fare tale controllo e usare l'oggetto come fosse qualunque altro.

Per creare un oggetto che corrisponda al __concetto di nessun valore__ o __valore neutro__ nasce allora il pattern NullObject: si crea all'interno della classe o dell'interfaccia un _oggetto statico_ chiamato `NULL` che fornisce _particolari implementazioni dei metodi_ della stessa per realizzare l'idea di valore nullo a livello di dominio.
In questo modo tale oggetto mantiene l'identità della classe rimanendo però sufficientemente separato dagli altri valori; inoltre, la presenza di implementazioni specifiche dei metodi evita il lancio di eccezioni ambigue.

```java
public interface CardSource {
    Card draw();
    boolean isEmpty();

    public static CardSource NULL = new CardSource() {
        public boolean isEmpty() { 
            return true; 
        }
        public Card draw() {
            assert !isEmpty();
            return null;
        }
    }
}
```

Quindi possiamo notare che il concetto del NullObject pattern è quello di creare un oggetto in cui viene definito un comportamento specifico per ogni metodo che rispecchia ciò che accadrebbe nel caso in cui il metodo venisse chiamato su null nel normale flusso di istruzioni.

## <big>S</big>TRATEGY / <big>D</big>ELEGATION

Talvolta nelle nostre classi vogliamo definire __comportamenti diversi per diverse istanze__: la soluzione classica dei linguaggi Object-Oriented è la creazione di una gerarchia di classi in cui le classi figlie sovrascrivano i metodi della classe genitore.
Tuttavia, questo espone a delle problematiche: cosa fare se per esempio la classe genitore cambia aggiungendo un metodo che una delle classi figlie non dovrebbe poter implementare (es. `RubberDuck` come figlia di `Duck`, che aggiunge il metodo `fly()`)?

Non volendo violare il principio Open-Close, non siamo intenzionati a rimuovere il metodo incriminato, per cui dobbiamo cercare altre soluzioni. Una prima idea sarebbe quella di sopperire al fatto che la classe genitore non sappia chi sono i suoi figli con costrutti proprietari del linguaggio:

- una classe `Final` non permette di ereditare, ma questo non ci permetterebbe di differenziare il comportamento;
- una classe `Sealed` (aggiunta di Java 17) sceglie esplicitamente chi possano essere i suoi figli: in questo modo si può evitare che la classe figlia problematica non possa ereditare, ma si tratta comunque di una soluzione parziale.

Non si può neanche pensare di fare semplicemente l'override nella classe figlia del metodo aggiunto facendo in modo che lanci un'eccezione: si avrebbe infatti una inaccettabile violazione del principio di sostituzione di Liskov, che afferma sostanzialmente che un'istanza di una sottoclasse deve poter essere usata senza problemi al posto dell'istanza di una classe genitore.

Una soluzione migliore si basa invece sul concetto di __delega__, che sostituisce all'ereditarietà la _composizione_.
Fondamentalmente si tratta di individuare ciò che cambia nell'applicazione e separarlo da ciò che rimane fisso: si creano delle _interfacce per i comportamenti da diversificare_ e una _classe concreta che implementa ogni diverso comportamento_ possibile.
All'interno della classe originale si introducono dunque degli __attributi di comportamento__, impostati al momento della costruzione o con dei setter a seconda della dinamicità che vogliamo permettere: quando viene richiesto il comportamento a tale classe essa si limiterà a chiamare il proprio "oggetto di comportamento".
Nell'esempio delle `Duck`, per esempio, la struttura è la seguente:

{% plantuml style="width: 100%" %}
interface FlyBehavior << interface >> {
    + {abstract} fly()
}
class Duck {
    + performQuack()
    + performFly()
    + swim()
    + {abstract} display()
}
FlyBehavior <-o Duck
interface QuackBehavior << interface >> {
    + {abstract} quack()
}
Duck o-> QuackBehavior
class FlyWithWings implements FlyBehavior {
    + fly()
}
class FlyNoWay implements FlyBehavior {
    + fly()
} 
class Quack implements QuackBehavior {
    + quack()
}
class Mute implements QuackBehavior {
    + quack()
}
class Squeak implements QuackBehavior {
    + quack()
}
hide empty fields
{% endplantuml %}

Come si vede, qui non c'è scritto da nessuna parte che una `Duck` deve volare, ma solo che deve definire la sua "politica di volo" incorporando un `FlyBehaviour`.

La differenziazione dei comportamenti si fa dunque _a livello d'istanza_ e non di classe: il pattern definisce una famiglia algoritmi e li rende tra di loro intercambiabili tramite _encapsulation_.
Per questo motivo tale pattern è usato in situazioni anche molto diversa da quella con cui l'abbiamo introdotto: un altro esempio presente in Java è l'interfaccia `Comparator`.

{% plantuml style="width: 70%" %}
class Client {}
interface AbstractStrategy << interface >> {
    + {abstract} void doSomething()
}
Client .> AbstractStrategy
class ConcreteStrategy1 implements AbstractStrategy {
    + void doSomething()
}
class ConcreteStrategy2 implements AbstractStrategy {
    + void doSomething()
}
hide empty fields
{% endplantuml %}

## <big>O</big>BSERVER

Molto spesso capita di avere nei nostri programmi una serie di elementi che vanno tenuti sincronizzati: pensiamo per esempio ad una ruota dei colori che deve aggiornare i valori RGB quando l'utente seleziona un punto con il mouse. Abbiamo cioè uno __stato comune__ che va mantenuto coerente in tutti gli elementi che lo manipolano.

Nella realizzazione di questa funzionalità si rischia di cadere nell'anti-pattern delle _pairwise dependencies_ in cui ogni vista dello stato deve conoscere tutte le altre: si ha cioè un forte accoppiamento e una bassissima espandibilità, in quanto per aggiungere una vista dobbiamo modificare tutte le altre.
Ovviamente basta avere poco più di due diverse viste perché il numero di dipendenze (e dunque di errori) cresca esponenzialmente: questo anti-pattern è proprio tutto il contrario del principio di separazione, che predicava forte coesione interna e pochi accoppiamenti esterni.

{% plantuml style="width: 50%" %}
entity IntegerPanel {}
entity SliderPanel {}
entity TextPanel {}
IntegerPanel ..> SliderPanel
IntegerPanel ..> TextPanel
SliderPanel ..> IntegerPanel
SliderPanel .> TextPanel
TextPanel ..> IntegerPanel
TextPanel .> SliderPanel
hide members
{% endplantuml %}

La soluzione proposta dal pattern Observer è dunque quella di estrarre la parte comune (lo _stato_) e isolarlo in un oggetto a parte, detto __Subject__: tale oggetto verrà osservato da tutte le viste, le cui classi prendono ora il nome di __Observer__.
Si sta cioè __centralizzando__ la gestione dello stato: abbiamo cioè $$n$$ classi che osservano una classe centrale e reagiscono ad ogni cambiamento di stato di quest'ultima. \
Si tratta una situazione talmente comune che in Java erano presenti delle classi (ora deprecate in quanto non _thread-safe_) per realizzare questo pattern: `java.util.Observer` e `java.util.Observable`.

Ma come fanno gli Observer a sapere che il Subject è cambiato?
L'idea di fare un continuo _polling_ (chiedo "Sei cambiato?" al Subject), non è ovviamente sensata, in quanto bloccherebbe l'esecuzione sprecando tantissime risorse.
Invertiamo invece la responsabilità con un'architettura __event-driven__: gli Observer si _registrano_ al Subject, che li informerà quando avvengono cambiamenti di stato.

{% plantuml style="width: 100%" %}
class Observable {
    + addObserver(Observer)
    + removeObserver(Observer)
    + notifyObservers()
}
interface Observer << interface >> {
    + {abstract} update(Observable, Object)
}
Observable o-> Observer
class ConcreteObserver implements Observer {
    + update(Observable, Object)
}
class ConcreteObservable extends Observable {
    + getState() : State
    + setState(State)
}
ConcreteObservable <. ConcreteObserver
hide empty fields
{% endplantuml %}

Restano però da capire un paio di cose.
Bisogna innanzitutto spiegare _come colleghiamo Observer e Subject_: come si vede in figura, esiste una classe `Observable` che funge da base da cui ereditare per ogni Subject; vi è poi un'interfaccia `Observer` che gli Observer concreti devono ovviamente implementare.

A questo punto gli Observer si possono sottoscrivere al Subject semplicemente attraverso l'uso delle sue funzioni `addObserver()` e `removeObserver()`, venendo così sostanzialmente inseriti o rimossi nella lista interna degli Observer interessati. \
Una volta che lo stato del Subject viene cambiato, solitamente attraverso una serie di metodi pubblici che permettano a tutti di modificarlo (`setState()`), esso chiama dunque il suo metodo `notifyObservers()`: questo altro non fa che ciclare su tutti gli Observer sottoscritti chiamandone il metodo `update(Observable, Object)`, dove:

- `Observable` è il Subject di cui è stato modificato lo stato (l'uso di interfacce permette di sottoscrivere un Observer a più Subject tra cui disambiguare al momento dell'update)
- `Object` è la parte di stato che è cambiata (_Object_ perché il tipo dipende ovviamente dal Subject in questione)

Sul metodo di notifica del cambiamento di stato esistono però due diverse filosofie, __push__ e __pull__, ciascuna con i suoi campi applicativi prediletti: vediamole dunque singolarmente, evidenziando quando e come esse sono utilizzate.

### push

In questo caso l'argomento Observable di `update` viene messo nullo, mentre __nell'Object viene passata la totalità dello stato__ del Subject:

```java
// Observable
@Override
public void notifyObservers() {

    for (Observer observer : observers) {
        observer.update(null, state);
    }

}

// Observer
@Override
public void update(Observable model, Object state) {

    if (state instanceof Integer intValue) {
        doSomethingOn(intValue);
    }

}
```

Come si vede, dovendo definire come reagire al cambiamento di stato in `update` l'Observer dovrà innanzitutto fare un down-casting per ottenere un oggetto della classe corretta.
Avendo la responsabilità di tale casting l'Observer dovrà conoscere precisamente la struttura dello stato del Subject, creando una _forte dipendenza_ che potrebbe creare problemi di manutenibilità.

Un altro problema di questo approccio è che gli Observer sono solitamente interessati a una piccola porzione dello stato del Subject, quindi passarlo tutto come parametro potrebbe sovraccaricare inutilmente la memoria.

### pull

Con questo approccio, invece di mandare lo stato all'`update` __viene passato il Subject stesso__, il quale conterrà uno o più metodi per accedere allo stato (`getState`):

```java
// Observable
@Override
public void notifyObservers() {

    for (Observer observer : observers) {
        observer.update(this, null);
    }

}

// Observer
@Override
public void update(Observable model, Object state) {

    if (model instanceof ConcreteObservable cModel) {
        doSomethingOn(cModel.getState());
    }

}
```

Sebbene comporti un passaggio in più poiché l'Observer deve chiamare un metodo del Subject quando riceve la notifica, questo cambio di prospettiva offre due vantaggi: in primo luogo non viene passato tutto lo stato, il che fa risparmiare molta memoria; inoltre, il Subject potrebbe decidere di rendere disponibili sottoinsiemi diversi dello stato con getter diversi, mostrando così ad ogni Observer solo le informazioni per esso rilevanti.

Inoltre, sebbene anche in questo caso sia richiesto un casting (da Observable al Subject), questo approccio rende meno dipendenti dalla rappresentazione interna del Subject: fintanto che la firma dei getter non cambia lo stato interno del Setter può cambiare senza problemi.

### Approccio ibrido e dipendenze

Partiamo col dire che molto spesso nei casi reali gli approcci _push_ e _pull_ sono ibridati tra di loro: ad `update` viene passato sia il Subject che quella parte di stato utile a tutti gli Observer, mentre qualora gli serva qualcosa di più specifico essi se lo andranno a prendere con il getter.

Il vero problema di entrambi gli approcci è però quello delle dipendenze: nel caso _push_ dipendiamo dalla rappresentazione interna del Subject, mentre nel caso _pull_ dalla sua classe concreta.
Poiché tale dipendenza non è facilmente eliminabile, piuttosto che lasciarla nascosta nel casting conviene __esplicitarla__:

- all'interno dell'Observer salvo l'istanza di Observable a cui mi sono sottoscritto, così al momento dell'`update` posso verificare direttamente che l'istanza sia quella al posto di fare un casting;

- creiamo una classe `State` e l'aggreghiamo sia nell'Observer che nell'Observable concreto in modo che essa nasconda la rappresentazione reale dello stato.

Otteniamo dunque un codice simile al seguente:

```java
public class State { /* rappresentazione interna dello stato */ }

public class Observable {
    private State stato;
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(@NotNull Observer obs) { observers.add(obs); }
    public void removeObserver(@NotNull Observer obs) { observers.remove(obs); }
    public void notifyObservers() {
        for (Observer obs: observers) update(this, stato);
    }
}

public class Subject extends Observable {

    public void setState(State nuovoStato) { ... }
    public State getState() { return super.stato; }
    /* Opzionale: altri metodi getter */
}

public interface Observer {
    public void update(Observable subject, Object stato);
}

public class ConcreteObserver {
    private Observable mySubject;

    @Override
    public void update(Observable subject, Object stato) {
        if (subject == mySubject) {
            ...
        }
    }
}
```

## <big>A</big>DAPTER

Spesso nei programmi che scriviamo capita di dover __far collaborare interfacce diverse__ di componenti non originariamente sviluppati per lavorare insieme.
Questo capita in una miriade di situazioni, ma volendone citare alcune:

- in un ambito di sviluppo COTS (_Component Off The Shelf: sviluppiamo solo ciò che non è disponibile tramite librerie o codice open-source_) riutilizziamo tanti componenti presi dal mercato, non pensati per essere compatibili;
- sviluppando ed evolvendo un programma in modo _incrementale_ capita di dover integrare componenti nuovi con componenti vecchi (_legacy_) per garantire una certa continuità nell'esperienza utente.

Da tutta una serie di situazioni simili è nato il bisogno di creare delle strutture che permettessero di rendere compatibili componenti già esistenti, ovvero creare della _"colla"_ in grado di legare i componenti tra loro per soddisfare le specifiche del sistema.
È così ben presto scaturito il pattern __Adapter__, un pattern ormai molto diffuso che consiste nel creare vari moduli che possano essere incollati o adattati ad altre strutture in modo da renderle utilizzabili incrementalmente e in modo controllato. 

Sebbene sia già utilizzato molto spesso, talvolta anche inconsciamente, approfondiamo il pattern in questa sede non solo per imparare a usarlo con più criterio, ma anche perché di esso esistono due "versioni":

- __Class Adapter__: adatta una classe.
- __Object Adapter__: adatta un oggetto di una classe.

Come vedremo, questi due pattern sono molto simili a livello di schema UML ma abbastanza differenti da rendere importante capire quale usare in quali contesti, comprendendo vantaggi e svantaggi di entrambi.

### Class Adapter

{% plantuml style="width: 80%" %}
class Client {}
interface Target << interface >> {
    + {abstract} request()
}
Client .> Target
class Adaptee {
    + oldRequest()
}
class ClassAdapter implements Target {
    + request()
}
Adaptee <|-- ClassAdapter
hide empty fields
{% endplantuml %}

Come si vede dallo schema UML, per permettere a un _Client_ di comunicare tramite un'interfaccia _Target_ con un componente concreto vecchio detto _Adaptee_ il Class Adapter utilizza una classe concreta che __implementa l'interfaccia Target__ e __estende la classe Adaptee__, ereditandone così i metodi e la vecchia interfaccia: all'interno di tale classe potremo dunque limitarci a _rimappare le funzionalità_ richieste dalla nuova interfaccia su quella vecchia, implementando qualcosa solo se strettamente necessario e comunque sfruttando la logica già presente della classe estesa.

```java
public class Adapter extends Adaptee implements Target {
    @Override
    public void request() {
        this.oldRequest();
    }
}
```

In questo modo il client utilizzerà l'adapter come se fosse l'oggetto completo, non accorgendosi che quando ne chiama un metodo in realtà il codice eseguito è quello appartenente alla vecchia classe già esistente: in un __unica istanza__ si sono dunque riunte l'interfaccia vecchia e quella nuova.

Vediamo dunque quali sono i pro e i contro di questo approccio. È utile innanzitutto notare che estendendo l'Adaptee la classe Adapter ha parziale accesso alla sua rappresentazione interna, un vantaggio non da poco quando si considera quanto questo faciliti l'eventuale modifica di funzionalità; inoltre, essa ne eredita le definizioni dei metodi, e se questi non devono cambiare tra la vecchia interfaccia e la nuova si può evitare di ridefinirli totalmente, risparmiando così parecchio codice.

Inoltre, un'istanza della classe Adapter può essere utilizzata attraverso __entrambe le interfacce__ in quanto implementa quella nuova ed eredita quella vecchia; questo aspetto può essere considerato sia un vantaggio che uno svantaggio: se infatti da un lato ciò è molto utile in sistemi che evolvono incrementalmente e in cui dunque alcune componenti potrebbero volersi riferire ancora alla vecchia interfaccia, d'altro canto questo aspetto impedisce di imporre tassativamente che l'oggetto sia utilizzato solo tramite l'interfaccia nuova.

Va poi notato che questo approccio perde un po' di senso nel caso in cui si debba adattare un'_interfaccia_ e non una classe, in quanto implementare entrambe le interfacce non permette di ereditare codice o funzionalità da quella vecchia.
Inoltre, il Class Adapter potrebbe presentare problemi relativi all'ereditarietà multipla, non supportata da alcuni linguaggi a oggetti (es. Java).

### Object Adapter

{% plantuml style="width: 80%" %}
class Client {}
interface Target << interface >> {
    + {abstract} request()
}
Client .> Target
class ObjectAdapter implements Target {
    + request()
}
class Adaptee {
    + oldRequest()
}
ObjectAdapter o-> Adaptee
hide empty fields
{% endplantuml %}

Come abbiamo già detto più volte, spesso conviene prediligere la _composizione_ rispetto all'ereditarietà: al pattern del Class Adapter si contrappone dunque l'Object Adapter, che invece di estendere la classe Adaptee __contiene una sua istanza__ e __delega__ ad essa tramite la vecchia interfaccia le chiamate ai metodi dell'interfaccia nuova, eventualmente operando i necessari rimaneggiamenti.

```java
public class Adapter implements Target {
    private final Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        assert adaptee != null;
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.oldRequest();
    }
}
```

Anche in questo caso il client non si accorge di nulla, e in particolare non sarebbe nemmeno in grado di dire con certezza se l'Adapter utilizzato sia un Class Adapter o un Object Adapter: a lui la scelta del paradigma è del tutto trasparente.

Rispetto al Class Adapter l'Object Adapter presenta differenti punti di forza e di debolezza, e il primo di questi ultimi è rappresentato dal fatto che invece di avere un'unica istanza che racchiuda entrambe le interfacce con questo pattern abbiamo invece _due istanze_ (Adapter e Adaptee contenuto), cosa che può costituire un notevole spreco di memoria in certe situazioni. 

Inoltre, aver sostituito l'ereditarietà con la composizione ha lo sgradevole effetto di non permettere all'Adapter di vedere in alcun modo la rappresentazione protetta dell'Adaptee, che esso dovrà invece manipolare unicamente tramite la sua interfaccia pubblica.
Si è poi costretti a _reimplementare ogni metodo_ anche se questo non è cambiato dall'interfaccia vecchia a quella nuova, in quanto è comunque necessario operare la delega all'Adaptee.

Tuttavia, l'Object Adapter si rivela particolarmente utile nel caso ad essere adattata debba essere un'_interfaccia_: non soffrendo di problemi di ereditarietà, un Object Adapter ha la peculiarità di poter adattare chiunque implementi la vecchia interfaccia, ovvero un'intera _gerarchia_ di classi potenzialmente non ancora esistenti!

#### Class Adapter vs Object Adapter

Class Adapter e Object Adapter hanno ciascuno i propri vantaggi e svantaggi che li rendono più adatti ad essere utilizzati in diverse situazioni.
Volendo fare un confronto tra i due approcci proponiamo dunque la seguente tabella:

| Aspetto | Class Adapter | Object Adapter |
|---------|---------------|----------------|
| Accesso all'Adaptee | <span style="color:green">L'Adapter può accedere ad attribuiti e metodi protetti dell'Adaptee</span> | <span style="color:red">L'Adapter può interagire con l'Adaptee solo tramite la sua interfaccia pubblica</span>|
| Riuso del codice | <span style="color:green">Non richiede di reimplementare i metodi che non cambiano</span> | <span style="color:red">Qualunque metodo va reimplementato per fare la delega</span> |
| Uso della memoria | <span style="color:green">Un'unica istanza</span> | <span style="color:red">Due istanze obbligatorie</span> |
| Adozione delle interfacce | <span style="color:#ff9900">L'istanza può essere usata con entrambe le interfacce</span> | <span style="color:#ff9900">L'istanza può essere usata solo tramite la nuova interfaccia</span> |
| Problemi di ereditarietà multipla | <span style="color:red">Possibili</span> | <span style="color:green">No</span>|
| Adattamento delle interfacce | <span style="color:red">Non è indicato</span> | <span style="color:green">Adattando un'interfaccia può adattare un'intera gerarchia di classi</span>|

<span> <!-- ugly spacer --> </span>

## <big>F</big>ACADE

Costruendo un sistema complesso può capitare di dover definire una serie di interfacce molto specifiche e dettagliate per i propri componenti in modo che questi possano lavorare correttamente in concerto tra di loro.
Il problema sorge però quando un Client, dovendo accedere al sistema, si ritrova costretto a dover interagire direttamente con i sottosistemi che lo compongono, cosa che lo obbliga a sviscerare i funzionamenti interni dello stesso per ottenere un comportamento tutto sommato semplice.

Lo scopo del pattern Facade è allora quello di __fornire un'interfaccia unificata e semplificata a un insieme di interfacce separate__: spesso infatti l'uso comune di un sistema si riduce un paio di operazioni ottenibili combinando varie funzionalità fornite dal package; invece di richiedere al Client di operare tale composizione facciamo ricadere sulle nostre spalle tale compito costruendo una _classe_ che faccia da _interfaccia standard_ al sistema.

{% responsive_image path: assets/09_facade.png %}

Si noti come questo non impedisca al Client di usare anche le funzionalità più complesse, ma metta solo ulteriormente a disposizione un'interfaccia che gli permetta di sfruttare facilmente quelle più frequentemente utilizzate.
Volendo fornire un esempio nella vita reale, un telecomando fornisce un'interfaccia semplice ai controlli della televisione, permettendo di regolare il volume e cambiare canale con semplicità: aprendo però uno sportellino ecco che ci vengono forniti tutti i comandi più specifici.

## <big>C</big>OMPOSITE

Immaginiamo di dover modellare un file system in un'applicazione: esso sarà composto di File e Directory, le quali dovranno essere in grado di contenere al loro interno File e ulteriori Directory; dovremo cioè ottenere una struttura ad albero di Directory avente dei File come foglie.
Se però molte funzionalità del file system operano in modo analogo sia sui File che sulle Directory (_es. creazione, cancellazione, ottenimento della dimensione etc._), come possiamo gestire queste due classi in modo uniforme per evitare di duplicare il codice?

Per gestire simili strutture ad albero che rappresentano _insiemi e gerarchie di parti_ viene introdotto il pattern __Composite__: esso mira a gestire oggetti singoli, gruppi e persino gruppi di gruppi in maniera uniforme e trasparente in modo che un client non interessato alla struttura gerarchica possa utilizzarli senza accorgersi delle differenze.

{% plantuml style="width: 80%" %}
interface Component << interface >> {
    + {abstract} sampleOperation()
}
class Leaf implements Component {
    + sampleOperation()
}
class Composite {
    + sampleOperation()
    + add(Component)
    + remove(Component)
}
Composite .|> Component
Composite "0..1" o-> "0..n" Component
hide empty fields
{% endplantuml %}

Abbiamo quindi gli oggetti singoli, rappresentati dalla classe _Leaf_, e gli oggetti composti rappresentati dalla classe _Composite_.
Per realizzare l'uniformità di gestione dobbiamo introdurre un livello di astrazione, quindi Leaf e Composite implementano una stessa __interfaccia Component__ contenente la definizione delle operazioni comuni. \
L'uso dell'interfaccia comune permette di definire all'interno di Composite le operazioni di aggiunta e rimozione di oggetti al gruppo in modo generale, permettendo cioè che un _Composite aggreghi sia Leaf che altri Composite_.

A proposito di tale aggregazione, dallo schema UML possiamo notare le relative cardinalità: "0..n" dal lato del Composite e "0..1" da quello del Component.
Esse indicano che:

- Un'istanza di Composite aggrega 0 più istanze di Component al suo interno: in questo modo si permette che al momento della creazione il Composite sia totalmente vuoto; se questo non ha alcun senso logico nell'applicazione si può invece modificare la cardinalità in "1..n" imponendo che al costruttore di Composite venga passato un Component iniziale da contenere;

- Un'istanza di Component può essere contenuta in al più un'istanza di Composite: può cioè essere libero o aggregato in un gruppo, ma non può appartenere contemporaneamente a più gruppi, cosa che forza una struttura strettamente ad albero.

Nella maggior parte dei casi un'istanza Composite utilizzerà gli oggetti aggregati per implementare effettivamente i metodi descritti dall'interfaccia comune, delegando a loro l'esecuzione effettiva e limitandosi ad elaborare i risultati.
Riprendendo l'esempio di prima, per conoscere la dimensione di una Directory sarà sufficiente sommare le dimensioni dei File e delle altre Directory in essa contenuti.

Il patter Composite presenta numerosi vantaggi, ma non è nemmeno esente da criticità.
L'uso di un'interfaccia comune per Leaf e Composite permette al client di non preoccuparsi del tipo dell'oggetto con cui sta interagendo, in quanto ogni Component è in grado di eseguire le operazioni descritte nell'interfaccia in modo indistinguibile; tuttavia, questo implica che non è possibile distinguere tra oggetti singoli e composti. \
Inoltre, l'uso dell'interfaccia per l'aggregazione nei Composite rende impossibile imporre dei controlli su cosa possa contenere un certo tipo di Composite: non si può per esempio forzare che raggruppi solo certi tipi di elementi, o che l'albero di composizione abbia profondità al più pari a tre.

Un "dialetto" del pattern tenta di risolvere il problema dell'indistinguibilità tra Leaf e Composite introducendo nell'interfaccia Component un metodo `getComposite` che in un Composite restituisca `this` e in una Leaf restituisca `null`.
L'uso di valori nulli e la necessità di strani casting rende però pericolosa l'adozione di questa versione del pattern.

## <big>D</big>ECORATOR

Immaginiamo di voler modellare con degli oggetti una grande varietà di pizze differenti sia per la base (_es. normale, integrale, senza glutine..._) che per gli ingredienti che vi si trovano sopra.
Per ogni diversa varietà di pizza vorremmo ottenere un oggetto aderente a un'interfaccia comune `Pizza` il cui metodo `toString()` elenchi la base e gli ingredienti che la compongono.

Un primo approccio _statico_ a questo problema consiste nel creare una gerarchia di classi che contenga una classe per ogni possibile combinazione di base e ingredienti, che d'ora in avanti chiameremo "__decorazioni__".

```java
public interface Pizza {}

public class BaseNormale implements Pizza {
    public String toString() {return "Sono una pizza con: base normale";}
}

public class BaseIntegrale implements Pizza {
    public String toString() {return "Sono una pizza con: base integrale";}
}

public class BaseNormaleSalame extends BaseNormale {
    public String toString() {return "Sono una pizza con: base normale, salame";}
}

public class BaseNormaleSalamePeperoni extends BaseNormaleSalame {
    public String toString() {return "Sono una pizza con: base normale, salame, peperoni";}
}

...
```

Come è subito ovvio, però, questo approccio risulta assolutamente da evitare per una serie di motivi: in primo luogo l'esplosione combinatoria dovuta all'accoppiamento di ogni possibile base e insieme di decorazioni, e in secondo luogo l'estrema difficoltà che comporterebbe una futura aggiunta di decorazioni.

L'ideale sarebbe invece poter __aggiungere funzionalità e caratteristiche dinamicamente__, restringendo la gerarchia ad un'unica classe le cui istanze possano essere "decorate" su richiesta al momento dell'esecuzione. \
La soluzione più semplice a questo nuovo problema parrebbe quella che viene definita una <big>G</big>OD CLASS (o _fat class_), ovvero un'unica classe in cui tramite attributi booleani e `switch` vengono attivate o disattivate diverse decorazioni.

```java
public class GodPizza {

    boolean baseNormale = false;
    boolean baseIntegrale = false;
    ...

    boolean salame = false;
    boolean pancetta = false;
    boolean peperoni = false;
    ...

    public void setBaseNormale(boolean status) {baseNormale = status;}
    public void setBaseIntegrale(boolean status) {baseIntegrale = status;}
    ...

    public void setSalame(boolean status) {salame = status;}
    public void setPancetta(boolean status) {pancetta = status;}
    public void setPeperoni(boolean status) {peperoni = status;}
    ...

    public String toString() {
        StringBuilder sb = new StringBuilder("Sono una pizza con: ");
        if (baseNormale) sb.append("base normale, ");
        if (baseIntegrale) sb.append("base integrale, ");
        ...
        if (salame) sb.append("salame, ");
        if (pancetta) sb.append("pancetta, ");
        if (peperoni) sb.append("peperoni, ");
        ...
        sb.removeCharAt(sb.length() - 1);
        sb.removeCharAt(sb.length() - 1);
        return sb.toString();
    }
}
```

Si tratta però questo di un chiaro anti-pattern, una soluzione che sebbene invitante e semplice in un primo momento da realizzare nasconde delle criticità non trascurabili.
Si tratta infatti di una chiara violazione dell'Open-Close Principle, in quanto per aggiungere un decoratore è necessario modificare la God Class; inoltre, tale classe diventa molto velocemente gigantesca, zeppa di funzionalità tra loro molto diverse (_scarsa separazione delle responsabilità_) e decisamente infernale da leggere, gestire e debuggare in caso di errori.

Introduciamo dunque il pattern __Decorator__, la soluzione più universalmente riconosciuta per questo tipo di situazioni.

{% plantuml style="width: 80%" %}
    interface Component << interface >> {
        + {abstract} sampleOperation()
    }
    class ConcreteComponent implements Component {
        + sampleOperation()
        }
    class Decorator {
        + Decorator()
    }
    Decorator .|> Component
    Decorator "0..1" o-> "0..1" Component
    hide empty fields
{% endplantuml %}

A prima vista lo schema UML ricorda molto quello del pattern Composite: abbiamo un'interfaccia _Component_ implementata sia da un _ConcreteComponent_, ovvero una base della pizza nel nostro esempio, sia da una __classe astratta Decorator__, la quale è poi estesa da una serie di _ConcreteDecorator_.
A differenza del Composite, tuttavia, qui ciascun Decorator aggrega __una e una sola istanza di Component__: tali decoratori sono infatti dei "wrapper", degli oggetti che _ricoprono_ altri per aumentarne dinamicamente le funzionalità. \
È importante notare che i Decorator ricevono come oggetto da ricoprire al momento della costruzione un _generico Component_, in quanto questo permette ai decoratori di decorare oggetti già decorati.
Questo approccio "ricorsivo" permette di creare una catena di decoratori che definisca a runtime in modo semplice e pulito oggetti dotati di moltissime funzionalità aggiunte.
I decoratori esporranno infatti i metodi definiti dall'interfaccia __delegando__ al Component contenuto l'esecuzione del comportamento principale e aggiungendo la propria funzionalità a posteriori: in questo modo la "base" concreta eseguirà il proprio metodo che verrà successivamente arricchito dai decoratori in maniera del tutto trasparente al Client.

```java
public interface Pizza { String toString(); }

public class BaseNormale implements Pizza {
    public String toString() {return "Io sono una pizza con: base normale";}
}

public class BaseIntegrale implements Pizza {
    public String toString() {return "Io sono una pizza con: base integrale";}
}

public abstract class IngredienteDecorator implements Pizza {
    private Pizza base;

    public IngredienteDecorator(Pizza base) {this.base = base;}

    public String toString() {
        return base.toString();
    }
}

public class IngredienteSalame extends IngredienteDecorator {
    public IngredienteSalame(Pizza base) {super(base);}

    @Override
    public String toString() {return super.toString() + ", salame";}
}

public class IngredientePeperoni extends IngredienteDecorator {
    public IngredientePeperoni(Pizza base) {super(base);}

    @Override
    public String toString() {return super.toString() + ", peperoni";}
}
```

```java
public class Client {
    public static void Main() {
        //Voglio una pizza con salame, peperoni e base integrale
        Pizza salamePeperoni = 
            new IngredientePeperoni(
                new IngredienteSalame(
                    new BaseIntegrale()));
    }
}

```

Vista la somiglianza, inoltre, pattern Decorator e Composite sono facilmente combinabili: si può per esempio immaginare di creare gruppi di oggetti decorati o decorare in un solo colpo gruppi di oggetti semplicemente facendo in modo che Composite, Decorator e classi concrete condividano la stessa interfaccia Component.

Possiamo poi notare una cosa: al momento della costruzione un Decorator salva al proprio interno l'istanza del Component da decorare.
Come sappiamo questo darebbe luogo ad un'_escaping reference_, ma in questo caso il comportamento è assolutamente voluto: dovendo decorare un oggetto è infatti sensato pensare che a quest'ultimo debba essere lasciata la possibilità di cambiare e che debba essere il decoratore ad adattarsi a tale cambiamento.


È interessante poi osservare la classe astratta Decorator: in essa viene infatti inserita tutta la logica di composizione, permettendo così di creare nuovi decoratori con estrema facilità.
Spesso, inoltre, se i decoratori condividono una certa parte di funzionalità aggiunte queste vengono anch'esse estratte nella classe astratta creando invece un metodo vuoto protetto che i decoratori reimplementeranno per operare la loro funzionalità aggiuntiva.

```java
public abstract class IngredienteDecorator implements Pizza {
    private Pizza base;

    public IngredienteDecorator(Pizza base) {this.base = base;}

    public String toString() {
        return base.toString() + nomeIngrediente();
    }

    protected String nomeIngrediente() {return "";}
}

public class IngredienteSalame extends IngredienteDecorator {
    public IngredienteSalame(Pizza base) {super(base);}

    @Override
    public String nomeIngrediente() {return ", salame";}
}

public class IngredientePeperoni extends IngredienteDecorator {
    public IngredientePeperoni(Pizza base) {super(base);}

    @Override
    public String nomeIngrediente() {return ", peperoni";}
}
```

Si noti come l'uso della visibilità `protected` renda l'override del metodo possibile anche al di fuori del package, aumentando così la facilità di aggiunta di nuovi decoratori.

Volendo vedere un esempio concreto di utilizzo di questo pattern è sufficiente guardare alla libreria standard di Java: in essa infatti gli `InputStream` sono realizzati seguendo tale schema.

## <big>S</big>TATE PATTERN
Lo state pattern viene utilizzato quando abbiamo una situazione in cui è necessario modellare i comportamenti di un oggetto al modificarsi del suo stato.
Può capitare di dover modellare qualcosa tramite una macchina a stati finiti, e grazie a questo pattern possiamo mantenere questa rappresentazione anche durante l'implementazione.
Il punto di forza di questo pattern è che risulta molto facile apportare delle modifiche al codice quando le specifiche di ciò che abbiamo modellato tramite una macchina a stati finiti cambiano.

Un esempio di utilizzo di questo pattern potrebbe essere un software di editing di foto, in cui abbiamo una toolbar con diversi strumenti, e ognuno di essi ci permette di compiere un'operazione diversa sullo stesso piano di lavoro.
Premendo sull'opzione scala e successivamente selezionando la foto potremmo scalarla, successivamente scegliendo l'opzione ruota e selezionando la stessa foto di prima sullo stesso piano di lavoro il software ci permetterà di ruotarla.
Tutte le volte che abbiamo delle situazioni analoghe potrebbe essere la soluzione migliore utilizzare lo state pattern, piuttosto che creare uno switch in cui gestire tutti i diversi casi.

```java
public class Context implements CardSource {
    private State state

    public void setState(@NotNull State s) {
        state = s;
    }

    public void sampleOperatio() {
        state.sampleOperation(this)
    }
}
```

{% plantuml style="width: 80%" %}
class Context {
    + sampleOperation()
    + setState(state)
}
interface State << interface >> {
    + {abstract} sampleOperation(Context)
}
class ConcreteState implements State {
   + sampleOperation(Context)
}
Context <|-- ConcreteState
Context "   1" o-> State
hide empty fields
{% endplantuml %}

Questo schema mostra come è strutturato il patterm, ovvero abbiamo una classe che può rispondere a diversi eventi (sampleOperation).
L'implementazione della risposta all'evento non scritta nella classe (context) ma per ogni stato in cui è possibile trovarsi esiste una classe che implementa il metodo in risposta all'evento, inoltre è possibile che avvenga un cambio di stato come conseguenza all'operazione appena fatta (per rendere l'idea possiamo prendere per esempio vim che quando diamo il comando i entra in modalità inserimento, quindi in risposta al comando i lo stato cambia da visualizzazione ad inserimento).
Quindi abbiamo due concetti fondamentali, ovvero:
- Cosa devo fare in un certo stato
- Cambiare di stato dopo una certa operazione

Lo schema appena mostrato è molto simile a quello del pattern strategy, con la differenza che gli stati sono a conoscienza degli altri stati, cosa che non accadeva nel pattern strategy, ogni strategia era indipendente dalle altre.
Questa conoscienza tra stati non si nota dallo schema, però è facile comprenderne il motivo in quanto dentro ad uno stato potrei dover sapere in che stato devo andare (vedi esempio precedente di vim).
Questo concetto però rende "sporco" l'uso dello state pattern, allora sono stati creati diversi approcci, tra cui:
- È compito del contesto permettere la transizione dello stato, evitando cosi che i diversi stati si conoscano. In questo modo l'operazione viene fatta in due step, ovvero la chiamata di sampleOperation e successivamente la transizione dello stato in base al risultato della chiamata (fatta nella classe Context). Questo meccanismo è un po una rimappatura del vecchio modello chiamato table driven design, in cui era presente una tabella formata da linee e colonne dove rispettivamente erano presetni stati e operazioni, e tramite un controllore veniva scelto lo stato successivo, come se fosse una macchina a stati finiti con le funzioni di transizione.
- Se non è possibile gestire il cambio di stato nella classe Context perché troppo dipendente da come viene eseguita l'azione l'unica soluzione che rimane è quella di mettere la possibilità di cambiare lo stato all'interno delle classi stesse.

Possiamo notare inoltre che lo stato non possiede alcun attributo (l'unica informazione che danno è essere se stesso), ma passiamo come parametro il contesto al metodo sampleOperation di State, quindi di fatto sono degli stati "stateless".
Questo ci da il vantaggio di rendere gli stati condivisibile, quindi non avremo un'istanza di ConcreteState per ogni oggetto che si trova in quello stato ma possiamo crearne una sola utilizzabile da più oggetti (esempio: se abbiamo x distributori di merendine che si trovano nello stato vuoto ci basterà un unico oggetto condiviso da tutti i distributori, e l'informazione che contraddistingue lo stato è interna al distributore, quindi verrà passata come parametro al metodo dell'oggetto stato vuoto).

## <big>F</big>ACTORY METHOD PATTERN
Questo pattern definisce una interfaccia per creare un oggetto ma lascia alle sottoclassi la scelta di cosa creare, ovvero posso scrivere delle istruzioni che mi richiedono la creazione di un oggetto pur non sapendo che oggetto voglio creare, quindi verrà richiamato del codice non ancora scritto che mi specifica cosa voglio creare (la scelta viene fatta a runtime, quindi si sfrutta polimorfismo e collegamento dinamico)
Si potrebbe pensare di implementare questo pattern tramite dei metodi statici della classe, ma non è un'implementazione corretta in quanto in un metodo statico devo specificare cosa voglio creare (tramite una _new_), quindi andremmo a perdere la dinamicità fornita dal polimorfismo e collegamento dinamico.

{% plantuml style="width: 100%" %}
interface Product << interface >> {
}
abstract class Creator {
    + {abstract} factoryMethod()
    + anOperation()
}
class ConcreteCreator implements Creator {
    + factoryMethod()
}
class ConcreteProduct implements Product {
}
ConcreteProduct <. ConcreteCreator
hide empty fields
{% endplantuml %}

Vediamo un esempio per capire meglio il suo funzionamento:

Consideriamo un software capace di aprire più documenti di tipo differente in diverse pagine all'interno della stessa applicazione senza dover chiudere il programma e riaprirlo con un nuovo file, per esempio word o excel.
Quando creo un nuovo file tra le varie operazioni generiche ho anche il metodo che effettivamente mi crea un nuovo oggetto documento, il cui codice che lo implementa non può stare nella classe astratta applicazioneMultidocumento (che nello schema di prima sarebbe Creator), questo perché una parte di esso è specifica per la tipologia di documento creato.
Per risolvere questo problema dovremmo trovare una strategia per estrarre la chiamata new specifica per quel tipo di documento e renderla virtuale (ovvero di cui possiamo fare l'overriding, e da questo il Factory method un altro nome, ovvero virtual constructor).
Sfruttando ciò avremo un metodo createDocument comune alle applicazioni multidocumeto, in cui le implementazioni saranno all'interno della sottoclassi delle specifiche applicazioni (nel nostro schema sarebbero oggetti di tipo ConcreteCreator e rappresentano word, execl, powerpoint, ecc, e al loro interno avranno dei metodi specifici per creare i diversi documenti specifici, come per esempio creatrWordDocumetn, createExecDocument, ecc).

{% plantuml style="width: 100%" %}
interface Document << interface >> {
    {abstract} Open()
    {abstract} Close()
    Save()
    Revers()
}
abstract class Application {
    + {abstract} CreateDocument()
    + NewDocument()
    + OpenDocument()
}
class MyApplication implements Application {
    + CreateDocument()
}
class MyDocument implements Document {
}
MyDocument <. MyApplication
Document <-o "     docs" Application
note right of Application::"NewDocument()"
Document doc = new CreateDocument();
docs.add(doc)
doc.Open()
end note

note right of MyApplication::"CreateDocument()"
return new MyDocument
end note
hide empty fields
{% endplantuml %}

Da questo esempio possiamo notare il concetto del Factory method, ovvero ho un template in cui normalmente non posso fare l'overriding di ciò che è parametrico come il costruttore (in cui ho le new), allora la soluzione è virtualizzare questa parte mettendo le new all'interno di un metodo che posso esportare.

## <big>A</big>BSTRACT FACTORY PATTERN
Questo metodo fornisce un'interfaccia per creare famiglie di oggetti dipendenti tra loro senza specificare la loro classe concreta.
Possiamo vederla come una composizione di tanti factory method e risolve un problema di omogeneita che avremmo in alcuni casi utilizzando il Factory Method.
Creo una volta sola una factory concreta che possiede una serie di factory method che permettono la creazione di una serie di prodotti concreti che sono tutti coerenti in stile tra di loro, e il client chiama i diversi factory method per creare gli oggetti che vuole

{% plantuml style="width: 100%" %}
class client {
}
interface AbstractFactory {
    + createProductA()
    + createProductA()
}
interface AbstractProduct <<interface>> {
}
client --> AbstractFactory
client --> AbstractProduct
class ConcreteFactory implements AbstractFactory {
    + createProductA()
    + createProductA()
}
class ConcreteProduct implements AbstractProduct {
}
hide empty fields
{% endplantuml %}

Un esempio che puo chiarire l'utilizzo dell'abstract factory è il seguente:
Mettiamo caso di voler creare degli elementi di una User Interface cross platform in modo tale da poter creare dei software in grado di utilizzare lo stile in base al sistema operativo selezionato.
Per implementare ciò sfruttando l'Abstract Factory pattern dobbiamo creare un'interfaccia GUIFactory che contiene la dichiarazione di due metodi creazionali chiamati createButton e createCheckbox, questi permetteranno al client di creare un bottone e una checkbox nello stile specificato dalla classe concreta della factory.
In questo esempio abbiamo due classi concrete che implementano GUIFactory chiamate MacFactory e WinFactory, e emulano rispettivamente lo stile di MacOS e di Windows.
I differenti elemetni della UI sono dichiarati tramite delle interfaccie specifiche, una per i bottoni (Button) e una per le checkbox (checkbox), e ognuna di esse verrà estesa da tante classi concrete quante sono le factory concrete (quindi in questo caso avremo WinButton e WinCheckbox per la classe WinFactory e MacButton e MacCheckbox per la classe MacFactory).
Infine il client, ovvero l'applicazione che sfrutta la UI possiede al suo interno un riferimento alla factory che è stata scelta, e tramite quella creerà tutti gli elementi di cui ha bisogno, senza preoccuparsi di specificare ogni volta lo stile, sa che quando ha bisogno di un elemento basta farlo creare alla factory e lei glielo restituirà nello stile selezionato inizialmente.

{% responsive_image path: assets/09_esempio-abstract-factory.png %}

## <big>M</big>ODEL VIEW CONTROLLER PATTERN
Abbiamo una suddivisione della nostra appicazione in tre parti che svolgono compiti differenti, quindi non sono strettamente dipendenti tra loro ma cooperano per permettere il funzionamento dell'applicazione.
Le tre parti in questione sono:
- Model: Questa parte contiene i dati e lo stato dell'applicazione; il model e la view sono collegati tra di loro tramite il pettern observer.
- View: Questa sezione comprende la parte di user interface, ovvero tutti gli elementi necessari all'utente per interagire con l'applicazione, e una volta che questo succede avviene un'interazione con la parte di controllo.
- Controller: Questa sezione comprende la logica dell'applicazione, quindi ogni volta viene ricevuto un input tramite la view il controller attua un comportamento specifico in risposta all'input, e facendo ciò cambia lo stato dell'applicazione che risiede nel model.

La view non conosce direttamente la struttura del model, ovvero non sa come sono salvati i dati al suo interno e neanche come è strutturato, di conseguenza la comunicazione tra i due è mediata tramite un controller (questo ci permette di poter riutilizzare una view con diversi modelli, la cosa fondamentale è che venga utilizzato un controller che li metta in comunicazione).
Il model una volta che il suo stato cambia avvisa tutte le viste che sono interessate al cambiamento, ovviamente la vista specifica da cui è partito l'input conosce già il cambiamento di stato perchè è stata lei a richiederlo, però tutte le altre viste dipendenti da quello specifico cambiamento vengono avvisate dal model.

Può essere utile che il controller sia in grado di comunicare alla vista da cui è partito l'input dei cambiamenti virtuali ancora prima che venga informato il model di cambiare il suo stato.
Questo avviene per esempio quando ci sono degli errori nell'input, di conseguenza non comunico al model di cambiare il suo stato, ma sarà il controller a fornire un cambiamento alla vista per informare l'utente dell'errore (questo può avvenire quando per esempio quando il formato di un dato inserito non è corretto).
Un altro scenario potrebbe essere che l'utente inserisce dei dati che sono già presenti del model, e in questo caso il controller non può saperlo, di conseguenza avviserà il model che risponderà con un errore specificando che i dati sono già presenti.
A questo punto il controller mostra i cambiamenti solo alla view che ha chiesto il cambiamento specificando che l'inserimento dei dati non è andato a buon fine, ma ciò avviene solo dopo che il model ha avvisato il controller dell'errore (infatti nel grafico sotto il punto 3 avviene dopo che il model è stato contattato dal controller al punto 2).

{% responsive_image path: assets/09_model-view-controller.png %}

Per adottare tutti questi meccanismi che vanno a formare il model view controller si sfruttano dei patter che abbiamo già visto, tra cui:
- __Observer__: Le view interessate si registrano al model come observers e quando lo stato del model cambia le view registrate vengono avvisate del cambiamento.
Il model conosce gli observers ma gli observers non conoscono il model, a meno che non si è in modalità pull, in quel caso viene passato un riferimento al model quando viene chiamato il metodo update, se siamo in modalità push invece gli observers sanno solo come gli viene passata l'informazione di stato.
Molto spesso se l'interfaccia è grafica (interfaccia ad eventi) anche la comunicazione tra view e controller può avvenire tramite il pattern Observer, ovvero il controller si registra come listener degli eveneti dell'interfacia grafica.
- __Strategy__: La reazione del controller in risposta ad un certo evento può essere visto come pattern strategy, ovvero quale è la strategia utilizzata per rispondere agli specifici eventi della nostra applicazione.
Tramite il pattern strategy possiamo utilizzare la stessa vista in modi differenti, ad esempio in alcuni stati la vista può essere read only e in altri casi è possibile fare delle modifiche, questo si può fare sfruttando controller differenti, utilizzati in base alla situazione e che rispondono agli eventi in modo differente.
La view non si accorge neanche di questo cambiamento, sa solo che in base all'evento deve avvisare una certa procedura, come questo evento viene gestito dalla procedura è la strategia, e questa può cambiare utilizzando controller differenti che implementano le procedure in modo diverso.
- __Composite__: Una view realizzata tramite un'interfaccia grafica può essere creata componendo diversi elementi tra loro (text area, buttons, ecc).
Quando viene chiamato il metodo che disegna l'interfaccia deve essere chiamato anche su tutti gli elementi che compongono la compongono, questo si fa componendo degli elementi semplici aderenti alla stessa interfaccia (ovvero avendo come riferimento lo schema del pattern composite, l'interfaccia component).
Facendo un esempio concreto abbiamo una window (composite) che contiene dei bottoni, campi di testo, slider e cosi via (Leaf che sono implementazioni dell'interfaccia component) e quando andiamo a chiamare il metodo drow sulla window, questo verrà rimappato su ogni elemento contenuto nella window.

Quindi possiamo concludere che il model può interagire con differenti interfacce tramite un unico comando (update), mentre le view possono comunicare con il model senza problemi tramite controller che fa da "adapter" tra i due.
Questo ci permette di avere delle interfacce disomogenee senza alcun tipo di problema riguardante il funzionamento dell'applicazione.

Il problema principale del model view controller è che abbiamo una dipendenza circolare tra i tre componenti, ovvero il controller deve prendere l'input dalla view e fare delle manipolazioni per poi permettere la modifica dello stato da parte del model, che a sua volta deve comunicare con la view in quanto a seconda del cambiamento alcune parti della view potrebbero subire modifiche (il modo in cui si fa questo dipende dalla modalità con cui l'observer notifica il cambiamento di stato).
Questo è scomodo perchè rende difficile capire da dove partire quando si sviluppa (potremmo mockare la vista per iniziare dal resto, ma comunque questa struttura complica le cose), inoltre testare la view è particolarmente complesso.

## <big>M</big>ODEL VIEW PRESENTER PATTERN
Per risolvere il problema appena descritto esiste una variante del model view controller chiamata __Model View Presenter__, che ci permette di semplificare il testing dell'interfaccia (o addirittura non testarla).
La prima cosa da notare è che il controller ora fa da intermediatrio non solo per la comunicazione tra vista e modello, ma anche tra modello e vista, in questo modo possiamo escludere la view e testare tutto il resto senza alcun problema in quanto non abbiamo legami diretti tra model e view.
In conclusione model view presenter ci permette di isolarci dalla parte grafica rendendo più semplice sviluppare e testare la parte logica (model e presenter), ovviamente l'interfaccia è ancora presente ma possiamo dedicarci ad essa in maniera separata dopo che tutta la parte logica è stata realizzata, cosi facendoa anche il testing della parte grafica diventa più semplice (design for testing).

Data questa separazione è importante mantenere segreta la rappresentazione del model al presenter e viceversa, anche se sono strettamente connessi tra loro, questo perchè se si è arrivati al punto di separare le responsabilità dividendo in classi differenti model e presenter, e successivamente si espongono i segreti di queste due il pattern perderebbe di significato.

{% responsive_image path: assets/09_model-view-presenter.png %}

## <big>B</big>UILDER PATTERN
Il pattern builder cerca di risolvere il problema che si presenta quando si ha un contruttore al cui interno bisgna gestire tanti parametri e magari non tutti sono obbligatori.
### Alternativa: Telescoping constructor pattern
Molte volte si sfrutta un altro pattern chiamato __Telescoping constructor pattern__ in cui ci sono tanti costruttori quante sono le combinazioni possibili di assegnazione di attributi opzionali, e molto spesso tutti i costruttori riutilizzano il costruttore che assegna tutti i parametri.
Quando si hanno tanti parametri diventa confusionario adottare questa tecnica perchè gia con 3 parametri opzionali i costruttori diventano molti.
Ecco un esempio di Telescopic constructor pattern:
```java
public class MyClass {
    private final T0 optionalField1;
    private final T1 mandatoryField;
    private final T2 optionalField2;

    public MyClass(T1 mf) {
        this(defaultValue1, mf, defaultValue2);
    }

    public MyClass(T1 mf, T0 of) {
        this(of, mf, defaultValue2);
    }

    public MyClass(T1 mf, T2 of) {
        this(defaultValue1, mf, of);
    }

    public MyClass(T1 mf, T0 of1, T2 of2) {
        this.optionalField1 = of1;
        this.optionalField2 = of2;
        this.mandatoryField = mf;
    }
}
```
In questo esempio abbiamo i attributi opzionali con tipi differenti, ma se i due attributi fossero stati dello stesso tipo avremmo avuto un problema di sintassi in quanto non si sarebbe potuto distinguere il costruttore che assegna il primo valore opzionale ma non il secondo e viceversa.
Questo problema non si può risolvere cambiando il nome del costruttore siccome è necessario che abbia lo stesso nome della classe, di conseguenza con questo pattern abbiamo la possibilità di avere opzionalità su parametri dello stesso tipo.

### Alternativa: JavaBeans pattern
Una soluzione al problema del telescopic constructor patter è quella di fornire un costruttore a cui si passano dei parametri per tutti gli attributi obblicatori, e successivamente si mettono a disposizione dei setter per impostare tutti gli attributi opzionali.

```java
public class MyClass {
    private T0 optionalField1;
    private T1 mandatoryField;
    private T2 optionalField2;

    public MyClass(T1 mf) {
        this.mandatoryField = mf;
    }

    public void setOptionalField1(T0 of) {
        this.optionalField1 = of;
    }

    public void setOptionalField2(T2 of) {
        this.optionalField2 = of;
    }
}
```

Una differenza che distingue questi due pattern è che il telescopic constructor pattern mi permette di poter creare oggetti immutabili (non sono obbligato ma posso farlo), mentre con il JavaBeans pattern sono obbligato a creare oggetti mutabili siccome non posso impostare gli attributi come final, altrimenti non poteri utilizzare i setter.
Il JavaBeans pattern assume che ci possono essere momenti in cui non ho ancora costruito completamente l'oggetto, il che risulta pericoloso in alcune situazioni come per esempio nei sistemi concorrenti.

### Builder Pattern
Il pattern builder cerca di prendere le parti migliori di ognuno dei due patter appena visti, ovvero permette di rendere finali gli attributi (e quindi permettere la creazione di oggetti immutabili) e anche di settare solo alcune parti dell'oggetto senza avere problemi di inconsistenza e senza avere problemi nella sovrapposizione dei tipi degli attributi.
Questo pattern fa parte dei pattern creazionali, ovvero quelli che si occupano della risoluzione dei problemi su come vengono creati gli oggetti.

sezione del libro Effective Java con spiegazione del builder pattern:
> _Item 2: Consider a builder when faced with many constructor parameters_

{% plantuml style="width: 100%" %}
class MyClass {
    - OptionalField : T0
    - MandatoryField : T1

    - MyClass(Builder)
}
class MyClass.Builder {
    + Builder(T1)
    + withOptionalField(T0) : Builder
    + build() : MyClass
}
MyClass *-- MyClass.Builder
hide empty fields
{% endplantuml %}

<!-- è stata utilizzata questo tipo di freccia nell'UML delle slice: MyClass +-- MyClass.Builder però non mi è chiaro se la freccia della composizione utilizzata sopra può andare bene comunque oppure no -->

```java
public class MyClass {
    private final T0 optionalField1;
    private final T1 mandatoryField;
    private final T2 optionalField2;

    private MyClass(Builder builder) {
        mandatoryField = builder.mandatoryField;
        optionalField1 = builder.optionalField1;
        optionalField2 = builder.optionalField2;
    }

    public static class Builder {
        private T1 mandatoryField;
        private T0 optionalField1 = defaultValue1;
        private T2 optionalField2 = defaultValue2;

        public Builder(T1 mf) {
            mandatoryField = mf;
        }

        public Builder withOptionalField1(T0 of) {
            optionalField1 = of;
            return this;
        }

        public Builder withOptionalField2(T2 of) {
            optionalField2 = of;
            return this;
        }

        public MyClass build() {
            return new MyClass(this);
        }
    }
}
```
Non posso costruire direttamente direttamente gli oggetti della classe MyClass in quanto il costruttore è privato, però abbiamo una classe statica innestata.
Essendo statica non è necessario istanziare prima la classe che la contiene, siccome non contengono nessun riferimento ad essa, inoltre per accedere dall'esterno alla nested class statica basta usare la seguente sintassi:
```java
ClasseEsterna.ClasseInnestata = new ClasseEsterna.ClasseInnestata();
```
<!-- controllare questa parte perché su internet ho trovato che la inner class statica può accedere solo agli elementi statici della classe superiore, ma il prof in aula ha detto che la classe builder può accedere a tutti gli elementi privati di MyClass senza menzionare nulla sil fatto che devono essere statici o no gli elemetni di MyClass per accedervi dalla classe builder -->

Il fatto di avere una classe statica Builder in MyClass permette che MyClass possa accedere agli attributi privati di Builder, e inoltre Builder può accedere agli attributi privati di MyClass.
Un altro particolare da notare è che dentro i setter degli attributi opzionali in builder viene ritornato l'oggetto builder in modo tale da poter concatenare l'uno con l'altro ed utilizzare una notazione più fluente.
Infine abbiamo un metodo build() che ci permette di chiamare e ritornare il costruttore di MyClass passandogli se stesso, ovvero il contenuto di Builder.

Quindi utilizzando questa tencica prima di chiamare build() è già presente l'oggetto builder settato, ma dall'esterno non ho un oggetto MyClass, quindi non è ancora accessibile e di conseguenza non posso avere inconsistenze o creazioni parziali dell'oggetto.
A questo punto quando avviene la chiamata build() ho già deciso i valori di tutti gli attribui, sia obbligatori che opzionali (con valore di default o perchè sono stati impostati con un setter).

quindi per creare un oggetto MyClass bisognerà farlo nel seguente modo:
```java
MyClass oggetto = new MyClass.Builder(mandatoryField).withOptionalField1(optionalField1).build();
```
<!-- Non ho verificato che questa sintassi sia corretta -->

e a questo punto è possibile decidere quali e quanti valori opzionali settare tramite i setter, quelli che non verranno settati avranno un valore di default impostato all'interno di Builder.
Quando viene chiamato il metodo build() verranno copiati i valori presenti dentro builder all'interno dell oggetto di tipo MyClass, e solo qui verranno settati, mai in futuro siccome non sono presenti dei setter per modificare gli attributi dentro MyClass e quindi posso mettereli final.
Questo ultimo punto non è obbligatorio, è possibile mettere un setter in MyClass in modo da modificare un attributo, ma a quel punto non può più essere final (da ciò si capisce che questo pattern permette di creare oggetti sia mutabili che immutabili).
