---
layout: post
title: "[09] Patterns"
date:   2022-10-26 14:30:00 +0200
toc: true
---

# Patterns

Il pattern è ........
L'idioma è ....

I meta patterns identificano due elementi base:
- __HookMethod__: un metodo astratto che determina il comportamento specifico nelle sottoclassi. È un _punto caldo_ in cui si può intervenire per personalizzare, adattare lo schema.
- __TemplateMethod__: pmetodo che coordina generalmente più hook metodo. È l'_elemento freddo_ di inviariabilità del pattern.

Come si realizzano l'_hook_ e il _template_? 
- __Unification__: nella stessa classe. L'_hook_ è astratto, il _template_ è concreto.
- __Connection__: hook e template sono in classi separate indicate ripsettivamente come _hook class_ e _template class_ tra di loro collegate da un'assocazione.
- __........__

## <big>S</big>INGLETON

Cerca di definire il concetto di UNO oggetto / UNA istanza in linguaggi in cui vengono fornite solo classi.
Si vuole rendere la classe responsabile del fatto che non può esistere più di una istanza.

```java
public class Singleton {
    /* costruttore privato o comunque non pubblico */
    protected Singleton() { ... }

    /* salvo l'istanza per usarla dopo */
    private static Singleton instance = null;

    /* metodo statico */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void sampleOp() { ... }
}
```

Un problema di questo pattern è l'accesso concorrente.
Al primo accesso di `getInstance` è possibile che due processi concorrenti la chiamino generando due istanze. 
Una soluzione sarebbe utilizzare la keyword `synchronized` di Java, ma rallenterebbe tutto il sistema (per l'acquire del lock) portando vantaggi solo alla prima chiamata.

... discorso java 5 ...

### Idioma Java

```java
public enum MySingleton {
    INSTANCE;

    public void sampleOp() { ... }
}

MySingleton.INSTANCE.sampleOp();
```

È thread safe, ma a prima vista è molto meno chiaro dell'approccio precedente.

## <big>I</big>TERATOR

Fornisce un modo per accedere agli elementi di un oggetto aggregatore in maniera sequenziale senza esporre la rappresentazione interna.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /* aggiunta funzionale opzionale */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

Per esempio, possiamo migliorare il progetto delle carte da così:
```java
Iterator<Card> cardIterator = deck.getCards();
while (cardIterator.hasNext()) {
    Card card = cardIterator.next();
    System.out.println(card.getSuit());
}
```

a così:

```java
for (Card card : deck) {
    System.out.println(card.getSuit());
}
```

È più chiaro, è palese che `card` sia read-only ed è supportato dall'IDE.

## <big>C</big>HAIN OF <big>R</big>ESPONSIBILITY
Permette di definire una catena di potenziali gestori di una richiesta di cui non sappiamo a priori chi sarà in grado di gestirla effettivamente.

## <big>F</big>LY<big>W</big>EIGHT

Serve a gestire una collezione di oggetti immutabili assicurandone l'unicità.

Quando le istanze equivalenti sono fortemente condivise all'interno del prograllam diventano auspicabili sia immutabili che unicità.
A differenza del <big>S</big>INGLETON, è difficile definire a priori quante istanze ci sono.

```java
public class Card {
    private static final Card[][] CARDS = new Card[Suit.values().length][Rank.values().length];

    static {
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                CARDS[suit.ordinal()][rank.ordinal()] = new Card(rank, suit);
            }
        }
    }

    public static Card get(Rank pRank, Suit pSuit) {
        return CARDS[pSuit.ordinal()][pRank.ordinal()];
    }
}
```

È un po' inefficiente perché alla prima computazione inizializza tutti gli oggetti, perdendo tempo e sprecando potenzialmente spazio.

## <big>D</big>ELEGATION / <big>S</big>TRATEGY

Fa parte della famiglia "gang of four" (GoF). 
Definisce una famiglia algoritmi e li rende (tramite _encapsulation_) tra di loro intercambiabili.

<!-- inserire immagine da slide 67 -->

## <big>O</big>BSERVER

Nasce per risolvere il probelam delle pairwise dependencies. 
Estraendo la parte comune (lo _stato_) lo mettiamo in un oggetto a parte (_subject_) che verrà osservato dagli altri (_observer_).
Ho quindi $$n$$ classi che osservano lo stato di una classe e reagiscono ad ogni cambiamento di stato di quest'ultima.

Il polling non va bene: spreca risorse. Gli observer si registrano al subject che li informa se ci sono cambiamenti: architettura __event-driven__.

È una situazione talmente comune che in Java erano presenti delle classi (ora deprecate in quanto non _thread-safe_) per realizzare questo pattern: `java.util.Observer` e `java.util.Observable`.

<!-- inserire immagine da slide 71 -->

### push
```java
// Observable
@Override
public void notifyObservers() {
    for (Observer observer : observers) {
        observer.update(null, state);
    }
}

// Observer
@Override
public void update(Observable model, Object state) {
    if (state instanceof Integer intValue) {
        doSomethingOn(intValue);
    }
}
```

Il problema di questo approccio è che gli observer sono solitamente interessati a un piccolo sottoinsieme dello stato, quindi inviarlo tutto interamente potrebbe creare problemi.

### pull

```java
// Observable
@Override
public void notifyObservers() {
    for (Observer observer : observers) {
        observer.update(this, null);
    }
}

// Observer
@Override
public void update(Observable model, Object state) {
    if (model instanceof ConcreteObservable cModel) {
        doSomethingOn(cModel.getState());
    }
}
```

Passando l'observable, quest'ultimo potrebbe offrire dei metodi per rendere disponibile solo dei sottoinsiemi dello stato.
