---
layout: post
title: "[09] Patterns"
date:   2022-10-26 14:30:00 +0200
toc: true
---

# Patterns

Il pattern è ........
L'idioma è ....

I meta patterns identificano due elementi base:
- __HookMethod__: un metodo astratto che determina il comportamento specifico nelle sottoclassi. È un _punto caldo_ in cui si può intervenire per personalizzare, adattare lo schema.
- __TemplateMethod__: pmetodo che coordina generalmente più hook metodo. È l'_elemento freddo_ di inviariabilità del pattern.

Come si realizzano l'_hook_ e il _template_? 
- __Unification__: nella stessa classe. L'_hook_ è astratto, il _template_ è concreto.
- __Connection__: hook e template sono in classi separate indicate ripsettivamente come _hook class_ e _template class_ tra di loro collegate da un'assocazione.
- __........__

## <big>S</big>INGLETON

Cerca di definire il concetto di UNO oggetto / UNA istanza in linguaggi in cui vengono fornite solo classi.
Si vuole rendere la classe responsabile del fatto che non può esistere più di una istanza.

```java
public class Singleton {
    /* costruttore privato o comunque non pubblico */
    protected Singleton() { ... }

    /* salvo l'istanza per usarla dopo */
    private static Singleton instance = null;

    /* metodo statico */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void sampleOp() { ... }
}
```

Un problema di questo pattern è l'accesso concorrente.
Al primo accesso di `getInstance` è possibile che due processi concorrenti la chiamino generando due istanze. 
Una soluzione sarebbe utilizzare la keyword `synchronized` di Java, ma rallenterebbe tutto il sistema (per l'acquire del lock) portando vantaggi solo alla prima chiamata.

... discorso java 5 ...

### Idioma Java

```java
public enum MySingleton {
    INSTANCE;

    public void sampleOp() { ... }
}

MySingleton.INSTANCE.sampleOp();
```

È thread safe, ma a prima vista è molto meno chiaro dell'approccio precedente.

## <big>I</big>TERATOR

Fornisce un modo per accedere agli elementi di un oggetto aggregatore in maniera sequenziale senza esporre la rappresentazione interna.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /* aggiunta funzionale opzionale */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

Per esempio, possiamo migliorare il progetto delle carte da così:
```java
Iterator<Card> cardIterator = deck.getCards();
while (cardIterator.hasNext()) {
    Card card = cardIterator.next();
    System.out.println(card.getSuit());
}
```

a così:

```java
for (Card card : deck) {
    System.out.println(card.getSuit());
}
```

È più chiaro, è palese che `card` sia read-only ed è supportato dall'IDE.

## <big>C</big>HAIN OF <big>R</big>ESPONSIBILITY
Permette di definire una catena di potenziali gestori di una richiesta di cui non sappiamo a priori chi sarà in grado di gestirla effettivamente.
