---
layout: post
title: "[09] Patterns"
date:   2022-10-26 14:30:00 +0200
toc: true
---

# Patterns

Parlando di progettazione del software e di buone pratiche è impossibile non parlare di __design patterns__, soluzioni universalmente riconosciute valide a problemi di design ricorrenti: si tratta cioè di strumenti concettuali di progettazione che esprimono un'architettura vincente del software catturando la soluzione ad una famiglia di problemi.

Ad ogni pattern sono associati una serie di __idiomi__, implementazioni del pattern specifiche per un certo linguaggio di programmazione che sfruttano i costrutti del linguaggio per realizzare l'architettura dettata dal pattern. Durante questa discussione vedremo alcuni idiomi per Java, che talvolta si discosteranno fortemente dalla struttura descritta dai diagrammi UML dei pattern.

Ma attenzione, esistono anche degli __anti-pattern__, soluzioni che _sembrano_ buone ma sono dimostratamente problematiche: dovremo assicurarci di tenerci lontani da questi design truffaldini!

#### Discutere di pattern: i meta-pattern

Prima di iniziare a parlare dei principali pattern che un informatico dovrebbe conoscere, possiamo chiederci come possiamo parlare di pattern: semplice, con dei _meta-patterns_, pattern con cui costruire altri pattern!

Nello specifico, i meta-patterns identificano due elementi base su cui ragionare quando si trattano i pattern:

- __HookMethod__: un "metodo astratto" che, implementato, determina il comportamento specifico nelle sottoclassi; è il _punto caldo_ su cui interveniamo per adattare lo schema alla situazione.

- __TemplateMethod__: metodo che coordina generalmente più HookMethod per realizzare il design voluto; è l'_elemento freddo_ di invariabilità del pattern che ne realizza la rigida struttura.

Ovviamente i metodi _template_ devono avere un modo per accedere ai metodi _hook_ se intendono utilizzarli per realizzare i pattern. Tale collegamento può essere fatto in tre modi differenti:

- __Unification__: _hook_ e _template_ si trovano nella stessa classe astratta, classe da cui erediteranno le classi concrete per implementare i metodi _hook_ e, di conseguenza, il pattern; i metodi _template_ sono invece già implementati in quanto la loro struttura non si deve adattare alla specifica applicazione.

{% plantuml style="width: 30%" %}
class TemplateHookClass {
  {abstract} hookMethod()
  templateMethod()
}
{% endplantuml %}

- __Connection__: _hook_ e _template_ sono in classi separate, indicate rispettivamente come _hook class_ (astratta) e _template class_ (concreta), collegate tra di loro da un'aggregazione: la classe template contiene cioè un'istanza della classe hook, in realtà un'istanza della classe concreta che realizza i metodi hook usati per implementare il pattern.

{% plantuml style="width: 25%" %}
class TemplateClass {
  templateMethod()
}
class HookClass {
  {abstract} hookMethod()
}
TemplateClass o--> HookClass 
{% endplantuml %}

- __Recursive connection__: come nel caso precedente _hook_ e _template_ sono in classi separate, ma oltre all'aggregazione tali classi sono qui legate anche da una relazione di generalizzazione: la classe template dipende infatti dalla classe hook.

{% plantuml style="width: 30%" %}
class TemplateClass {
  templateHookMethod()
}
class HookClass {
  {abstract} templateHookMethod()
}
TemplateClass --|> HookClass
TemplateClass o--> HookClass
{% endplantuml %}

Vedremo a quale meta-pattern aderiranno i pattern che vediamo. A tal proposito,i pattern che vedremo fanno parte dei cosiddetti "__Gang Of Four patterns__", una serie di 23 pattern definiti da Erich Gamma, Richard Helm, Ralph Johnson e John Vlissides; oltre ad averli definiti, questi signori hanno diviso i pattern in tre categorie:

- __Creazionali__: legati alla creazione di oggetti
- __Comportamentali__: legati all'interazione tra oggetti
- __Strutturali__: legati alla composizioni di classi e oggetti

## <big>S</big>INGLETON

Talvolta vorremmo che di un certo oggetto esistesse __una sola istanza__ perché logicamente di tale oggetto non ha senso esistano diverse copie all'interno dell'applicazione (es. diverse istanze della classe Gioco in un sistema che gestisce un solo gioco alla volta). Tuttavia i linguaggi Object-Oriented gestiscono solo classi con istanze multiple, per cui la realizzazione di questa unicità può rivelarsi più complessa del previsto.

La soluzione consiste nel rendere la classe stessa responsabile del fatto che non può esistere più di una sua istanza: per fare ciò il primo passo è ovviamente quello di _rendere privato il costruttore_, o se non privato comunque non pubblico (conviene metterlo protected in modo da poter creare sottotipi). \
Bisogna però garantire comunque un modo per recuperare l'unica istanza disponibile della classe: si crea dunque il _metodo statico_ `getInstance` che restituisce a chi lo chiama l'unica istanza della classe, creandola tramite il costruttore privato se questa non è già presente. Tale istanza è infatti memorizzata in un _attributo statico_ della classe stessa, in modo così da poterla restituire a chiunque ne abbia bisogno.

{% plantuml %}
class Singleton {
    + {static} instance : Singleton
    # Singleton()
    + {static} Singleton getInstance()
    + sampleOp()
}
{% endplantuml %}

Con queste accortezze è possibile creare una classe Singleton simile a questa:

```java
public class Singleton {
    /* costruttore privato o comunque non pubblico */
    protected Singleton() { ... }

    /* salvo l'istanza per usarla dopo */
    private static Singleton instance = null;

    /* metodo statico */
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void metodoIstanza() { ... }
}
```

Tuttavia, per come lo abbiamo scritto questa classe non assicura di non creare più di un'istanza di sé stessa, in quanto non prende in considerazione la __concorrenza__. Se due processi accedono in modo concorrente al metodo `getInstance`, entrambi potrebbero eseguire il controllo sul valore nullo dell'istanza ed ottenere un successo in quanto l'istanza non è ancora stata assegnata al relativo attributo statico nell'altro processo: si ottiene dunque che uno dei due processi ha accesso ad una propria istanza privata, cosa che distrugge completamente il nostro pattern!

Una prima soluzione sarebbe di mettere un lock sull'esecuzione del metodo anteponendovi la direttiva `@Synchronized`: tuttavia, tale approccio comporterebbe un notevole calo di prestazioni del sistema portando vantaggi unicamente alla prima chiamata. \
Una soluzione molto più efficiente (non possibile però fino a Java 5) è invece quella che prevede di avere un _blocco sincronizzato_ di istruzioni posto all'interno del ramo in cui si pensa che l'istanza sia nulla in cui ci si chiede se effettivamente l'istanza è nulla e solo allora si esegue il costruttore; la presenza del doppio controllo assicura che non vi siano squilibri dovuti alla concorrenza, mentre sincronizzare solamente un blocco e non l'intero metodo fa sì che il calo di prestazioni sia sentito solamente durante le prime chiamate concorrenti.

### Idioma Java

Fortunatamente si è sviluppato per il linguaggio Java un idioma molto semplice per il Singleton, in cui al posto di usare una classe per definire l'oggetto si usa un __enumerativo__ con un unico valore, l'istanza. Ciascun valore di tali oggetti è infatti trattato nativamente da Java proprio come un Singleton: viene creato al momento del suo primo uso, non ne esiste più di una copia, e chiunque vi acceda accede sempre alla medesima istanza. La possibilità di creare attributi e metodi all'interno degli `enum` completa il quadro.

```java
public enum MySingleton {
    INSTANCE;

    public void metodoIstanza() { ... }
}

MySingleton.INSTANCE.sampleOp();
```

Si tratta inoltre di un approccio "thread safe", ovvero che lavora già bene con la concorrenza; l'unico svantaggio è che, se non si conosce l'idioma, a prima vista questa soluzione risulta molto meno chiara rispetto all'approccio precedente.

## <big>I</big>TERATOR

Talvolta gli oggetti che definiamo fanno da __aggregatori__ di altri oggetti, contenendo cioè una collezione di questi su cui poi fare particolari operazioni: in questi casi è molto probabile che vorremo poter iterare sui singoli elementi aggregati, ma senza esporre la rappresentazione interna usata per contenerli.

Proprio per risolvere questo tipo di problematiche nasce il pattern Iterator: esso consiste nella creazione di una classe `ConcreteIterator` che abbia accesso alla rappresentazione interna del nostro oggetto e esponga i suoi elementi in modo sequenziale tramite i metodi `next()` e `hasNext()`; dovendo accedere alla rappresentazione, molto spesso tale iteratore si realizza come una _classe interna anonima_.

Java supporta largamente il pattern Iterator, a tal punto che nella libreria standard esiste un'interfaccia generica per gli iteratori, `Iterator<E>`: all'interno di tale interfaccia sono definiti, oltre ai metodi di cui sopra, il metodo `remove()`, normalmente non supportato in quanto permetterebbe di modificare la collezione contenuta dalla classe, e il metodo `forEachRemaining()`, che esegue una data azione su tutti gli elementi ancora non estratti dell'iteratore.

```java
public interface Iterator<E> {
    boolean hasNext();
    E next();

    default void remove() {
        throw new UnsupportedOperationException("remove");
    }

    /* aggiunta funzionale opzionale */
    default void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }
}
```

Esiste inoltre un'interfaccia che l'oggetto iterabile può implementare, `Iterable<E>`: essa richiede solamente la presenza di un metodo `iterator()` che restituisca l'iteratore concreto, e una volta implementata permette di utilizzare il proprio oggetto aggregatore all'interno di un costrutto foreach.

{% plantuml style="width:60%" %}
interface Iterable<T> << interface >> {
    + {abstract} Iterator<T> iterator()
}
interface Iterator<T> << interface >> {
    + {abstract} boolean hasNext()
    + {abstract} T next()
    + void remove()
    {method} ...
}
Iterable .> Iterator
class ConcreteIterable implements Iterable {
    + Iterator<T> iterator()
}
class ConcreteIterator implements Iterator {
    + boolean hasNext()
    + T next()
}
ConcreteIterable .> ConcreteIterator
hide empty fields
{% endplantuml %}

Così, per esempio, possiamo passare dal seguente codice:

```java
Iterator<Card> cardIterator = deck.getCards();
while (cardIterator.hasNext()) {
    Card card = cardIterator.next();
    System.out.println(card.getSuit());
}
```

... a quest'altro:

```java
for (Card card : deck) {
    System.out.println(card.getSuit());
}
```

Oltre ad essere più stringato il codice è significativamente più chiaro, rendendo palese che la singola `card` sia read-only.

## <big>C</big>HAIN OF <big>R</big>ESPONSIBILITY

Talvolta nei nostri programmi vorremmo definire una gestione "a cascata" di una certa richiesta. Pensiamo per esempio a una serie di regole anti-spam: all'arrivo di una mail la prima regola la esamina e si chiede se sia applicabile o meno; in caso affermativo contrassegna la mail come spam, altrimenti _la passa alla prossima regola_, che a sua volta farà lo stesso test passando il controllo alla terza in caso negativo, e così via. Abbiamo cioè un _client_ in grado di fare una richiesta, e una __catena di potenziali gestori__ di cui non sappiamo a priori chi sarà in grado di gestirla effettivamente.

Il pattern Chain of Responsibility risolve il disaccoppiamento tra client e gestore _concatenando i gestori_. Esso prescrive la creazione di un'interfaccia a cui tutti i gestori devono aderire, contenente solo la dichiarazione di un metodo `evaluate` che implementa la logica descritta prima: si stabilisce se si può gestire la richiesta, e se non si può si chiama lo stesso metodo su _un altro gestore_ ottenuto come parametro al momento della creazione.

{% plantuml style="width: 100%" %}
class PokerHand {
    + HandRank getRank()
}
interface ChainedHandEvaluator << interface >> {
    + {abstract} handEvaluator()
}
PokerHand -> ChainedHandEvaluator
ChainedHandEvaluator "0..1" o-> "0..1" ChainedHandEvaluator : next
class HighCardEvaluator implements ChainedHandEvaluator {
    + HighCardEvaluator(ChainedHandEvaluator)
    + handEvaluator()
}
note left of HighCardEvaluator::"handEvaluator()" 
    if (can_handle) { 
        return do_it(); 
    } else { 
        return next.handEvaluator(); 
    }
end note
hide empty fields
{% endplantuml %}

In questo modo all'interno del client è sufficiente creare una vera e propria catena di gestori e chiamare il metodo `evaluate` del primo: si noti che l'ordine in cui vengono assemblati tali gestori conta, in quanto la valutazione procede sequenzialmente.

```java
public interface Gestore {

    /* Il tipo di ritorno dipende dal campo applicativo */
    public ??? evaluate(); 

}

public class Client {

    private Gestore evaluator = 
        new GestoreConcreto1(
            new GestoreConcreto2(
                new GestoreConcreto3(null)));

    public void richiesta() {
        evaluator.evaluate();
    }

}
```

## <big>F</big>LY<big>W</big>EIGHT

Talvolta ci troviamo in una situazione simile a quella che aveva ispirato il pattern Singleton: abbiamo una __serie di oggetti immutabili fortemente condivisi__ all'interno del programma e per motivi di performance e risparmio di memoria vorremmo che _non esistano istanze diverse a parità di stato_. Se due client devono usare un'istanza con lo stesso stato vorremmo cioè non usino ciascuno un'istanza duplicata ma proprio la _stessa istanza_: essendo le istanze immutabili, tale condivisione non dovrebbe infatti creare alcun tipo di problema.

Il pattern FlyWeight serve a gestire una collezione di oggetti immutabili assicurandone l'unicità: esso consiste nel rendere privato il costruttore e __costruire tutte le istanze a priori con un costruttore statico__, salvandole in una lista privata. I client possono dunque richiedere una certa istanza con un metodo `get` specificando lo stato dell'istanza desiderata: in questo modo, a parità di richiesta verranno restituite le stesse identiche istanze.

Abbiamo visto un'applicazione di questo pattern durante i laboratori parlando di `Card`:

```java
public class Card {
    private static final Card[][] CARDS = new Card[Suit.values().length][Rank.values().length];

    static {
        for (Suit suit : Suit.values()) {
            for (Rank rank : Rank.values()) {
                CARDS[suit.ordinal()][rank.ordinal()] = new Card(rank, suit);
            }
        }
    }

    public static Card get(Rank pRank, Suit pSuit) {
        return CARDS[pSuit.ordinal()][pRank.ordinal()];
    }
}
```

A differenza del pattern Singleton è difficile definire a priori quante istanze ci sono: abbiamo un'istanza per ogni possibile combinazione dei valori degli attributi che compongono lo stato. Proprio per questo motivo il pattern può risultare un po' inefficiente per oggetti con rappresentazioni grandi: alla prima computazione vengono infatti inizializzati _tutti_ gli oggetti, perdendo un po' di tempo e sprecando potenzialmente spazio se non tutte le istanze saranno accedute.

## <big>N</big>ULL<big>O</big>BJECT

Spesso nei nostri programmi avremo bisogno di utilizzare valori "nulli": pensiamo per esempio al termine di una Chain of Responsibilities, dove per fermare la catena di chiamate dobbiamo dare un valore nullo al `next` dell'ultimo gestore. In generale, a una variabile che indica un riferimento ad un oggetto possiamo assegnare il valore speciale `null` per indicare che essa _non punta a nulla_.

Il problema sorge però quando a runtime si prova a dereferenziare tale valore e viene sollevata un'eccezione (`NullPointerException` in Java): questa possibilità ci costringe nel codice ad essere sempre molto titubanti sui valori che ci vengono passati, in quanto non possiamo mai assumere che essi puntino ad un valore reale e dunque dobbiamo sempre controllare che non siano nulli.

C'è però da dire che anche con tali accortezze l'utilizzo di `null` è poco carino, in quanto un valore nullo può indicare cose anche molto diverse:

- un errore a runtime
- uno stato temporaneamente inconsistente
- un valore assente o non valido

Ogni volta che si utilizza `null` il codice diventa un po' meno chiaro, e sarebbe necessario disambiguare con commenti o documentazione per spiegare con che accezione tale valore viene usato. Anche le strategie di gestione del `null` variano drasticamente a seconda del significato assegnato a tale valore: quando non ci sono valori "assenti" e dunque il `null` indica solo un errore è sufficiente controllare che i dati passati non siano nulli con condizioni, asserzioni o l'annotazione `@NotNull`.

{% responsive_image path: assets/09_nullObject-valori-non-assenti.png %}

Quando invece ci sono __valori "assenti"__, ovvero che indicano situazioni particolari (es. il Joker in un mazzo di carte, che non ha né Rank né Suit), la gestione è più complicata. Se non vogliamo trattarli come `null` per l'ambiguità che tale valore introduce, un'altra opzione è creare un metodo booleano nella classe che restituisce se l'istanza ha il valore nullo (es. `isJoker()`): tuttavia, questo apre le porte a errori da parte dell'utente, che potrebbe dimenticarsi di fare tale controllo e usare l'oggetto come fosse qualunque altro.

Per creare un oggetto che corrisponda al __concetto di nessun valore__ o __valore neutro__ nasce allora il pattern NullObject: si crea all'interno della classe o dell'interfaccia un _oggetto statico_ chiamato `NULL` che fornisce _particolari implementazioni dei metodi_ della stessa per realizzare l'idea di valore nullo a livello di dominio. In questo modo tale oggetto mantiene l'identità della classe rimanendo però sufficientemente separato dagli altri valori; inoltre, la presenza di implementazioni specifiche dei metodi evita il lancio di eccezioni ambigue.

```java
public interface CardSource {
    Card draw();
    boolean isEmpty();

    public static CardSource NULL = new CardSource() {
        public boolean isEmpty() { 
            return true; 
        }
        public Card draw() {
            assert !isEmpty();
            return null;
        }
    }
}
```
## <big>S</big>TRATEGY / <big>D</big>ELEGATION

Talvolta nelle nostre classi vogliamo definire __comportamenti diversi per diverse istanze__: la soluzione classica dei linguaggi Object-Oriented è la creazione di una gerarchia di classi in cui le classi figlie sovrascrivano i metodi della classe genitore. Tuttavia, questo espone a delle problematiche: cosa fare se per esempio la classe genitore cambia aggiungendo un metodo che una delle classi figlie non dovrebbe poter implementare (es. `RubberDuck` come figlia di `Duck`, che aggiunge il metodo `fly()`)?

Non volendo violare il principio Open-Close, non siamo intenzionati a rimuovere il metodo incriminato, per cui dobbiamo cercare altre soluzioni. Una prima idea sarebbe quella di sopperire al fatto che la classe genitore non sappia chi sono i suoi figli con costrutti proprietari del linguaggio:

- una classe `Final` non permette di ereditare, ma questo non ci permetterebbe di differenziare il comportamento;
- una classe `Sealed` (aggiunta di Java 17) sceglie esplicitamente chi possano essere i suoi figli: in questo modo si può evitare che la classe figlia problematica non possa ereditare, ma si tratta comunque di una soluzione parziale.

Non si può neanche pensare di fare semplicemente l'override nella classe figlia del metodo aggiunto facendo in modo che lanci un'eccezione: si avrebbe infatti una inaccettabile violazione del principio di sostituzione di Liskov.

Una soluzione migliore si basa invece sul concetto di __delega__, che sostituisce all'ereditarietà la _composizione_. Fondamentalmente si tratta di individuare ciò che cambia nell'applicazione e separarlo da ciò che rimane fisso: si creano delle _interfacce per i comportamenti da diversificare_ e una _classe concreta che implementa ogni diverso comportamento_ possibile. All'interno della classe originale si introducono dunque degli __attributi di comportamento__, impostati al momento della costruzione o con dei setter a seconda della dinamicità che vogliamo permettere: quando viene richiesto il comportamento a tale classe essa si limiterà a chiamare il proprio "oggetto di comportamento". Nell'esempio delle `Duck`, per esempio, la struttura è la seguente:

{% plantuml style="width: 100%" %}
interface FlyBehavior << interface >> {
    + {abstract} fly()
}
class Duck {
    + performQuack()
    + performFly()
    + swim()
    + {abstract} display()
}
FlyBehavior <-o Duck
interface QuackBehavior << interface >> {
    + {abstract} quack()
}
Duck o-> QuackBehavior
class FlyWithWings implements FlyBehavior {
    + fly()
}
class FlyNoWay implements FlyBehavior {
    + fly()
} 
class Quack implements QuackBehavior {
    + quack()
}
class Mute implements QuackBehavior {
    + quack()
}
class Squeak implements QuackBehavior {
    + quack()
}
hide empty fields
{% endplantuml %}

Come si vede, qui non c'è scritto da nessuna parte che una `Duck` deve volare, ma solo che deve definire la sua "politica di volo" incorporando un `FlyBehaviour`.

La differenziazione dei comportamenti si fa dunque _a livello d'istanza_ e non di classe: il pattern definisce una famiglia algoritmi e li rende tra di loro intercambiabili tramite _encapsulation_. Per questo motivo tale pattern è usato in situazioni anche molto diversa da quella con cui l'abbiamo introdotto: un altro esempio presente in Java è l'interfaccia `Comparator`.

{% plantuml style="width: 70%" %}
class Client {}
interface AbstractStrategy << interface >> {
    + {abstract} void doSomething()
}
Client .> AbstractStrategy
class ConcreteStrategy1 implements AbstractStrategy {
    + void doSomething()
}
class ConcreteStrategy2 implements AbstractStrategy {
    + void doSomething()
}
hide empty fields
{% endplantuml %}

## <big>O</big>BSERVER

Molto spesso capita di avere nei nostri programmi una serie di elementi che vanno tenuti sincronizzati: pensiamo per esempio ad una ruota dei colori che deve aggiornare i valori RGB quando l'utente seleziona un punto con il mouse. Abbiamo cioè uno __stato comune__ che va mantenuto coerente in tutti gli elementi che lo manipolano.

Nella realizzazione di questa funzionalità si rischia di cadere nell'anti-pattern delle _pairwise dependencies_ in cui ogni vista dello stato deve conoscere tutte le altre: si ha cioè un forte accoppiamento e una bassissima espandibilità, in quanto per aggiungere una vista dobbiamo modificare tutte le altre. Ovviamente basta avere poco più di due diverse viste perché il numero di dipendenze (e dunque di errori) cresca esponenzialmente: questo anti-pattern è proprio tutto il contrario del principio di separazione, che predicava forte coesione interna e pochi accoppiamenti esterni.

{% plantuml style="width: 50%" %}
entity IntegerPanel {}
entity SliderPanel {}
entity TextPanel {}
IntegerPanel ..> SliderPanel
IntegerPanel ..> TextPanel
SliderPanel ..> IntegerPanel
SliderPanel .> TextPanel
TextPanel ..> IntegerPanel
TextPanel .> SliderPanel
hide members
{% endplantuml %}

La soluzione proposta dal pattern Observer è dunque quella di estrarre la parte comune (lo _stato_) e isolarlo in un oggetto a parte, detto __Subject__: tale oggetto verrà osservato da tutte le viste, le cui classi prendono ora il nome di __Observer__. Si sta cioè __centralizzando__ la gestione dello stato: abbiamo cioè $$n$$ classi che osservano una classe centrale e reagiscono ad ogni cambiamento di stato di quest'ultima. \
Si tratta una situazione talmente comune che in Java erano presenti delle classi (ora deprecate in quanto non _thread-safe_) per realizzare questo pattern: `java.util.Observer` e `java.util.Observable`.

Ma come fanno gli Observer a sapere che il Subject è cambiato? L'idea di fare un continuo _polling_ (chiedo "Sei cambiato?" al Subject), non è ovviamente sensata, in quanto bloccherebbe l'esecuzione sprecando tantissime risorse. Invertiamo invece la responsabilità con un'architettura __event-driven__: gli Observer si _registrano_ al Subject, che li informerà quando avvengono cambiamenti di stato.

{% plantuml style="width: 100%" %}
class Observable {
    + addObserver(Observer)
    + removeObserver(Observer)
    + notifyObservers()
}
interface Observer << interface >> {
    + {abstract} update(Observable, Object)
}
Observable o-> Observer
class ConcreteObserver implements Observer {
    + update(Observable, Object)
}
class ConcreteObservable extends Observable {
    + getState() : State
    + setState(State)
}
ConcreteObservable <. ConcreteObserver
hide empty fields
{% endplantuml %}

Restano però da capire un paio di cose. Bisogna innanzitutto spiegare _come colleghiamo Observer e Subject_: come si vede in figura, esiste una classe `Observable` che funge da base da cui ereditare per ogni Subject; vi è poi un'interfaccia `Observer` che gli Observer concreti devono ovviamente implementare.

A questo punto gli Observer si possono sottoscrivere al Subject semplicemente attraverso l'uso delle sue funzioni `addObserver()` e `removeObserver()`, venendo così sostanzialmente inseriti o rimossi nella lista interna degli Observer interessati. \
Una volta che lo stato del Subject viene cambiato, solitamente attraverso una serie di metodi pubblici che permettano a tutti di modificarlo (`setState()`), esso chiama dunque il suo metodo `notifyObservers()`: questo altro non fa che ciclare su tutti gli Observer sottoscritti chiamandone il metodo `update(Observable, Object)`, dove:

- `Observable` è il Subject di cui è stato modificato lo stato (l'uso di interfacce permette di sottoscrivere un Observer a più Subject tra cui disambiguare al momento dell'update)
- `Object` è la parte di stato che è cambiata (_Object_ perché il tipo dipende ovviamente dal Subject in questione)

Sul metodo di notifica del cambiamento di stato esistono però due diverse filosofie, __push__ e __pull__, ciascuna con i suoi campi applicativi prediletti: vediamole dunque singolarmente, evidenziando quando e come esse sono utilizzate.

### push

In questo caso l'argomento Observable di `update` viene messo nullo, mentre __nell'Object viene passata la totalità dello stato__ del Subject:

```java
// Observable
@Override
public void notifyObservers() {

    for (Observer observer : observers) {
        observer.update(null, state);
    }

}

// Observer
@Override
public void update(Observable model, Object state) {

    if (state instanceof Integer intValue) {
        doSomethingOn(intValue);
    }

}
```

Come si vede, dovendo definire come reagire al cambiamento di stato in `update` l'Observer dovrà innanzitutto fare un down-casting per ottenere un oggetto della classe corretta. Avendo la responsabilità di tale casting l'Observer dovrà conoscere precisamente la struttura dello stato del Subject, creando una _forte dipendenza_ che potrebbe creare problemi di manutenibilità.

Un altro problema di questo approccio è che gli Observer sono solitamente interessati a una piccola porzione dello stato del Subject, quindi passarlo tutto come parametro potrebbe sovraccaricare inutilmente la memoria.

### pull

Con questo approccio, invece di mandare lo stato all'`update` __viene passato il Subject stesso__, il quale conterrà uno o più metodi per accedere allo stato (`getState`):

```java
// Observable
@Override
public void notifyObservers() {

    for (Observer observer : observers) {
        observer.update(this, null);
    }

}

// Observer
@Override
public void update(Observable model, Object state) {

    if (model instanceof ConcreteObservable cModel) {
        doSomethingOn(cModel.getState());
    }

}
```

Sebbene comporti un passaggio in più (l'Observer deve chiamare un metodo del Subject quando riceve la notifica), questo cambio di prospettiva offre due vantaggi: in primo luogo non viene passato tutto lo stato, il che fa risparmiare molta memoria; inoltre, il Subject potrebbe decidere di rendere disponibili sottoinsiemi diversi dello stato con getter diversi, mostrando così ad ogni Observer solo le informazioni per esso rilevanti.

Inoltre, sebbene anche in questo caso sia richiesto un casting (da Observable al Subject), questo approccio rende meno dipendenti dalla rappresentazione interna del Subject: fintanto che la firma dei getter non cambia lo stato interno del Setter può cambiare senza problemi.

### Approccio ibrido e dipendenze

Partiamo col dire che molto spesso nei casi reali gli approcci _push_ e _pull_ sono ibridati tra di loro: ad `update` viene passato sia il Subject che quella parte di stato utile a tutti gli Observer, mentre qualora gli serva qualcosa di più specifico essi se lo andranno a prendere con il getter.

Il vero problema di entrambi gli approcci è però quello delle dipendenze: nel caso _push_ dipendiamo dalla rappresentazione interna del Subject, mentre nel caso _pull_ dalla sua classe concreta. Poiché tale dipendenza non è facilmente eliminabile, piuttosto che lasciarla nascosta nel casting conviene __esplicitarla__:

- all'interno dell'Observer salvo l'istanza di Observable a cui mi sono sottoscritto, così al momento dell'`update` posso verificare direttamente che l'istanza sia quella al posto di fare un casting;

- creiamo una classe `State` e l'aggreghiamo sia nell'Observer che nell'Observable concreto in modo che essa nasconda la rappresentazione reale dello stato.

Otteniamo dunque un codice simile al seguente:

```java
public class State { /* rappresentazione interna dello stato */ }

public class Observable {
    private State stato;
    private List<Observer> observers = new ArrayList<>();

    public void addObserver(@NotNull Observer obs) { observers.add(obs); }
    public void removeObserver(@NotNull Observer obs) { observers.remove(obs); }
    public void notifyObservers() {
        for (Observer obs: observers) update(this, stato);
    }
}

public class Subject extends Observable {

    public void setState(State nuovoStato) { ... }
    public State getState() { return super.stato; }
    /* Opzionale: altri metodi getter */
}

public interface Observer {
    public void update(Observable subject, Object stato);
}

public class ConcreteObserver {
    private Observable mySubject;

    @Override
    public void update(Observable subject, Object stato) {
        if (subject == mySubject) {
            ...
        }
    }
}
```

## <big>A</big>DAPTER

Il pattern Adapter è un pattern usato molto spesso, a volte anche implicitamente, senza volerlo, quindi lo vediamo per poterlo usare più coscentemente e soprtatutto perchè ci sono due modalità per fare questo Adapter, di conseguenza dobbiamo capire quali dei due usare in quali contesti.
Per esempio, in un ambito di sviluppo COTS (Component Off The Shelf: basiamo lo sviluppo solo sulle parti che mancano, ovvero sviluppiamo ciò che non è disponibile tramite librerie o codice open source) riutilizziamo tanti componenti presi dal mercato.
Partendo da questa situazione si ha avuto il bisogno di creare delle strutture che permettessero di utilizzare queste componenti già esistenti in modo da renderle compatibili, ovvero creare la _"colla"_ che lega i componenti tra loro per soddisfare le specifiche del nostro sistema.
Un altro scenario potrebbe essere quello in cui devo far evolvere _incrementalmente_ (quindi l'utente non si deve accorgere di questo, oppure non devo avere una mancanza di servizio) un sistema mi trovo ad affrontare una situazione in cui ho dei componenti vecchi che devono collaborare con altri componenti più nuovi.

Per affrontare questi tipi di situazioni possiamo sfruttare il pattern __Adapter__, che consiste di creare dei moduli che possano essere incollati o adattati a delle altre strutture in modo da renderle utilizzabili incrementalmente e in modo controllato.

Abbiamo due versioni del pattern Adapter:
- Class Adapter: Adatto ad una classe.
- Object Adapter: Adatto ad un oggetto.

Sono simili a livello di UML, ma differenti.

### Class Adapter

```java
public class Adapter extends Adaptee implements Target {
    @Override
    public void request() {
        this.oldRequest();
    }
}
```

{% plantuml style="width: 80%" %}
class Client {}
interface Target << interface >> {
    + {abstract} request()
}
Client .> Target
class Adaptee {
    + oldRequest()
}
class ClassAdapter implements Target {
    + request()
}
Adaptee <|-- ClassAdapter
hide empty fields
{% endplantuml %}

In questo primo caso abbiamo la classe Adapter che implementa l'interfaccia target ed estende la classe già esistente che voglio adattare. Il client che deve utilizzare l'adapter non si accorge che quando ne usa un metodo in realtà il codice utilizzato per implementare quel metodo è quello di una classe già esistente.
In questo modo ho già tutte le funzionalità pronte e devo solo rimapparle sistemando i parametri oppure se devo reimplemenare qualcosa la logica è già presente.

Potremmo fare un qualcosa di diverso, modificando lo schema UML, potremmo modificare la freccia di ereditarietà tra Class Adapter e Adaptee e farla diventare una freccia di composizione, rispettando ciò che abbiao detto molte volte, ovvero prediligere la composizione rispetto all'ereditarietà, in modo da portare fuori un'aspetto dalla classe e poi da li sarà comunque possibile avere una gerarchia.

Questa cosa viene fatta nell'Object Adapter.

Nel class adapter potremmo avere dei problemi con l'ereditarietà multipla, siccome è necessario che l'adapter erediti l'adaptee e se oltre ad implementare l'interfaccia target deve estendere anche observable (o qualcos'altro) in java non lo posso fare siccome non supporta l'ereditarietà multipla.
Il fatto che il class adapter sia un unico oggetto che può essere usato contemporaneamente con due interfaccie diverse può essere un pro o un contro.
Se un metodo non cambia non devo fare niente (quindi meno codice da scrivere), a differenza dell'object adapter in cui non devo fare una delega

### Object Adapter

```java
public class Adapter implements Target {
    private final Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        assert adaptee != null;
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.oldRequest();
    }
}
```

{% plantuml style="width: 80%" %}
class Client {}
interface Target << interface >> {
    + {abstract} request()
}
Client .> Target
class ObjectAdapter implements Target {
    + request()
}
class Adaptee {
    + oldRequest()
}
ObjectAdapter o-> Adaptee
hide empty fields
{% endplantuml %}

Qui il client è nella stessa condizione di prima, quindi di fatto lui non si accorge se sta utilizzando un class adapter o un object adapter, a lui è del tutto trasparente.
La differenza è che l'Object adapter al posto di estendere l'adaptee, lo contiene, quindi è un suo attributo. In questo modo quando viene chiamato request viene delegato il compito al metodo dell'adaptee, e anche qui può essere un'operazione semplice in cui si devono sistemare solo i parametri oppure si può anche sfruttare la funzionalità già esistente per avere un comportamento differente.
Notiamo che solitamente quando devo sfruttare un adapter non posso accedere al contenuto privato dell'adaptee, solo se me lo fornisce lui posso accederci.

Abbiamo anche qui dei pro e dei contro, per esempio nell'object adapter abbiamo due oggetti distinti (contro), il nuovo oggetto non può più essere usato con l'interfaccia vecchia.
Il punto di forza dell'object adapter però è che adatta un intera gerarchia di classi potenzialmente non ancora esistente.

Confrontando questi due approcci possiamo notare delle differenze:
- Sfruttando il class adapter possiamo mostrare al client solo le funzionalità che vogliamo che usi, questo aspetto possiamo vederlo anche in maniera opposta, ovvero se devo sviluppare incrementalmente il mio software in modo da sostituire il vecchio componente con quello nuovo non sono sicuro che tutto il sistema sia già stato aggiornato per supportare il nuovo componente, potrebbero esserci delle parti che sfruttano ancora il vecchio componente. Quindi se faccio un oggetto class adapter in modo che _apparentemente_ unisce i due insiemi di funzionalità in modo che venga utilizzato sia come vecchio che come nuovo oggetto potrebbe essere un grande vantaggio. Il problema è che non ho la garanzia che nella nuova interfaccia non ci siano metodi con la stessa signature di metodi presenti nella vecchia interfaccia (per interfaccia si intende ciò che espongono il vecchio e il nuovo componente), se ciò avvenisse avremmo che il metodo della nuova interfaccia oscura quello della vecchia, e risulta problematico nel caso in cui i due metodi svolgono compiti diversi, perché magari l'utente si troverebbe ad utilizzare un metodo che prima faceva una cosa, ed ora svolge tutt'altro.
- Un'altra differenza è che nel class adapter abbiamo un unico oggetto, mentre nell'object adapter abbiamo un oggetto che ne contiene un altro. Questo potrebbe essere un problema quando abbiamo una grande stratificazione di adapter siccome avremo molta memoria occupata.
- Se dovessi trasformare un class adapter in un'interfaccia questo avrebbe poco senso siccome non sto ereditando del codice (potremmo ereditare metodi di default ma nei sistemi più vecchi non sono presenti in quanto i metodi di default sono abbastanza nuovi). Per quanto riguarda l'object adapter invece se fosse un'interfaccia avrebbe al suo interno un riferimento ad un oggetto compatibile con quell'interfaccia, in questo modo sto adattando non solo una classe ma potenzialmente un'intera gerarchia di classi che derivano da adaptee.
- Il Class Adapter ha la possibilità di accedere agli atttributi protetti di `Adaptee`
- L'Object Adapter nasconde i metodi che non reimplementiamo
- Con l'Object Adapter posso adattare anche interfacce, con il Class Adapter no. 

## <big>F</big>ACADE
Lo scopo del pattern Facade è quello di fornire un'interfaccia unificata e semplificata a un insieme di interfacce separate, ovvero se ho un insieme di package che può essere anche complesso, ma l'uso comune si riduce un paio di cose che si ottengono combinando funzionalità fornite dal package.
Un esempio è quello di un telecomando che fornisce un'interfaccia semplice dove possiamo alzare e abbassare il volume, spegnere il televisore e cambiare canale, e poi aprendo uno sportellino abbiamo tutti i comandi più specifici. Questo quindi non impedisce di usare tutte le funzionalità ma mette a disposizione un'interfaccia che ci permette di sfruttare quelle più frequentemente utilizzate.

## <big>C</big>OMPOSITE

Mira a gestire gruppi (anche gruppi di gruppi) e oggetti simili in maniera trasparente, ovvero trattandoli nella stessa maniera senza che mi accorga della differenza. Oppure possiamo dire che gestisce strutture ad albero per rappresentare gerarchie di parti e insiemi uniformemente.

{% plantuml style="width: 80%" %}
interface Component << interface >> {
    + {abstract} sampleOperation()
}
class Leaf implements Component {
    + sampleOperation()
}
class Composite {
    + sampleOperation()
    + add(Component)
    + remove(Component)
}
Composite .|> Component
Composite "0..1" o-> "0..n" Component
hide empty fields
{% endplantuml %}

Per gestire queste cose nello stesso modo devo avere un livello di astrazione, quindi Leaf e Composite implementano la stessa interfaccia, che è l'unica cosa visibile a chi utilizza a questo pattern, in modo da avere a disposizione le operazioni comuni. Inoltre dentro al composite dobbiamo aggregare altri component (Leaf e altri composite).

Notiamo che sull'aggregazione ci sono delle cardinatlità che indicano:
- Un'istanza di composite è collegata a 0 o n istanze di component, quindi in un composite possono esserci più component (con zero diciamo che esiste un momento della vita dell'oggetto composto i cui non ha neanche un componente, questa cosa però può essere modificata facendo in modo che quando l'oggetto composto viene costruito debba venirgli passato almento un componente).
- Un'istanza di component è collegata a 0 o 1 istanze di composite, quindi un component sta in 0 o 1 composite (in questo caso abbiamo la cardinalità 0 perché se avessimo messo 1 sarebbe stato necessario che ogni composite fosse stato in un altro composite, e cosi via ricorsivamente all'infinito, e questa cosa non è possibile, quindi la cardinalità 0 è necessaria).

Abbiamo dei vantaggi e degli svantaggi:
- Il cliente non deve preoccuparsi con cosa sta interagendo, può essere un oggetto composto o un singolo elemento, l'importante è che riesca a fare le operazioni disponibili indistintamente.
- Lo svantaggio invece è che non abbiamo controllo su che tipi di oggetti stanno dentro ad un particolare composite, quindi per esempio non possiamo raggruppare solo certe tipologie di elementi, oppure non possiamo decidere che l'albero deve avere massimo 3 livelli (ovvero non possiamo raggruppare fino al terzo livello).

Esempio strumenti di disegno:
Negli strumenti di disegno abbiamo la possibilità di raggruppare degli elementi (linee, forme, ecc) in modo da avere le stesse funzioni che avevamo sugli oggetti singoli ma applicate al gruppo.

### Esempio: Composite Card Source

`CompositeDeck` è un mazzo composto da mazzi e da insieme di mazzi ecc. Noi possiamo controllare se il mazzo è vuoto e pescare una carta, ecco il codice per fare ciò.

```java
public class CardSourceComp implements CardSource {
    @NotNull private List<CardSource> sources;

    public boolean isEmpty() {
        for (CardSource source : sources) {
            if (!source.isEmpty())
                return false;
            return true;
        }
    }
}
```

Per verificare che il mazzo è vuoto dobbiamo controllare se gli elementi che compongono il mazzo sono vuoti o no, appena ne trovo uno non vuoto ritorno false. se dentro il mazzo composto ci sono altri mazzi composti verrà fatto un controllo al loro interno ricorsivamente.

## <big>D</big>ECORATOR

Permette di aggiungere nuove funzionalità o caratteristice dinamicamente. Un esempio può essere quello della pizza, ovvero abbiamo una base su cui possiamo aggiungere degli ingredietni, ovvero delle decorazioni (possiamo aggiungere le stesse decorazioni più volte).
Queste decorazioni possono essere applicate a più basi differenti, per esempio la pizza normale, quella integrale, quella senza glutine, ecc.

Quindi vogliamo essere in grado di aggiungere delle funzionalità che prima non avevamo a delle "basi" in modo dinamico

### Esempio: carte

```java
public class LoggingDeck implements CardSource {
    public Card draw() {
        Card card = cards.pop();
        System.out.println(card);
        return card;
    }
}
```

La soluzione più semplice è creare una classe per ogni possibile decorazione, ma il numero cresce troppo velocemente portando un'enorme duplicazione del codice.

Un'altra soluzione è <big>G</big>OD CLASS (God class perché può fare qualsiasi cosa, un'altro nome è fat class perché diventa grossa molto facilmente): creo una classe unica in cui tramite degli attributi booleani e switch attuo le varie decorazioni.

```java
public class MultiModeDeck implements CardSource {
    boolean logging = false;
    boolean memo = false;

    public void setLogging(boolean status) {
        logging = status;
    }

    public void setMemo(boolean status) {
        memo = status;
    }

    public Card draw() {
        Card card = cards.pop();
        if (logging) System.out.println(card);
        if (memo) ...
        return card; 
    }
}
```

È un anti pattern forse peggiore, perché sembra una soluzione giusta e rapida ma in realtà va a violare l'open close principle, siccome ogni volta che aggiungo un decorator devo modificare anche la god class aggiungendo del codice per poter utilizzare il decoratore. Questo approccio causa dei problemi perché avremo una classe che fa troppe cose, e che diventa grande e complessa molto velocemente, di conseguenza è molto complessa da leggere e debuggare in caso di errori.

### Il vero pattern

{% plantuml style="width: 80%" %}
    interface Component << interface >> {
        + {abstract} sampleOperation()
    }
    class ConcreteComponent implements Component {
        + sampleOperation()
        }
    class Decorator {
        + Decorator()
    }
    Decorator .|> Component
    Decorator "0..1" o-> "0..1" Component
    hide empty fields
{% endplantuml %}

L'approccio corretto è simile a quanto abbiamo visto nel Composite pattern, ovvero abbiamo una di catena di oggetti l'uno che decora l'altro, quindi l'aggiunta di nuove responsabilità si fa tramite l'aggiunta di nuovi oggetti (abbiamo una sorta di ricorsione). Questo approccio presuppone che ci sia un componente su cui applicare le decorazioni (può essere un componente di base o anche un componente già decorato).

Il pattern decorator e il pattern composite non sono in mutua esclusione, possiamo combinarli. Partiamo dall'esempio del mazzo con il composite, possiamo decorare un elemento che compone il mazzo con un decoratore, quindi per esempio nel mio mazzo composto avremo un mazzo contenente gli assi su cui possiamo applicare il decoratore che ci permette di loggare le carte di quello specifico mazzo, e le altre no. Oppure posso decorare il composite di primo livello, in questo modo posso loggare tutte le carte.

### Esempio: carte 2
```java
public class LoggingDecorator implements CardSource {
    private final CardSource element;

    public LoggingDecorator(CardSource cardSource) {
        element = cardSource;
    }

    public boolean isEmpty() {
        return element.isEmpty();
    }

    public Card draw() {
        Card card = element.draw();
        System.out.println(card);
        return card;
    }
}
```

Possiamo raggruppare i metodi comuni nella classe astratta, e quindi dobbiamo solo riscrivere draw() e una parte del costruttore.

```java
public abstract class Decorator implements CardSource {
    private final CardSource element;

    public Decorator(CardSource element) {
        assert element != null;
        this.element = element;
    }

    @Override
    public Card draw() {
        return element.draw();
    }

    @Override 
    public boolean isEmpty() {
        return element.isEmpty();
    }
}
```

```java
public class LoggingDecorator extends Decorator {
    public LoggingDecorator(CardSource element) {
        super(element);
    }

    @Override
    public Card draw() {
        Card card = super.draw();
        System.out.println(card);
        return card;
    }
}
```
```java
public class MemoDecorator extends Decorator {
    private final List<Card> drawnCards;

    public MemoDEcorator(CardSource element) {
        super(element);
        drawnCards = new ArrayList<>();
    }

    @Override
    public 
    ...
}
```
Possiamo osservare però che abbiamo ancora uno scheletro comune, che possiamo sfruttare raggruppandolo ancora in modo da non dover riscrivere il metodo draw(), ma aggiungendo un metodo vuoto nella classe atratta (questo è un hook, ovvero un punto d'aggancio) che utilizzderemo nelle sottoclassi dove faremo un override e ci metteremo solo le linee di codice che differiscono nelle implementazioni di draw viste prima (da notare che sono la visibilità è protected nella classe astratta in modo che possa essere ridefinito anche fuori dal package)

```java
public abstract class Decorator implements CardSource {
    @NotNull private final CardSource element;

    public Decorator(@NotNull CardSource element) {
        this.element = element;
    }

    @Override 
    @NotNull
    public Card draw() {
        Card card = element.draw();
        decorationAction(card);
        return card;
    }

    @Override
    public boolean isEmpty() {
        return element.isEmpty();
    }

    protected void decorationAction(@NotNull Card card) {};
}
```

```java
public class LoggingDEcorator extends Decorator {
    public LoggingDecorator(@NotNull CardSource element) {
        super(element);
    }

    @Override
    protected void decorationAction(@NotNull Card card) {
        System.out.println(card);
    }
}
```
Sul libro Headfirst c'è un esempio di decorator citato dal prof, a cui bisogna stare attenti al parametro della classe astratta.

In java questo patter è utilizzato per implementare gli stram

